<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多言語学習アプリ</title>
        <!-- PWA用マニフェストへのリンク -->
    <link rel="manifest" href="./manifest.json" />
    <meta name="theme-color" content="#14b8a6" />

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 他のスタイル・スクリプト -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s, color 0.3s;
            -webkit-overflow-scrolling: touch;
            background-color: #f8fafc; /* bg-slate-50 */
            color: #334155; /* text-slate-700 */
        }
        /* 初期ページのテキストエリアのスタイルをより具体的に指定 */
        #input-section textarea {
            min-height: 100px;
            border-width: 2px; /* 枠線の太さを2pxに変更 */
            border-color: #64748b; /* border-slate-500 - より濃い色に変更 */
        }
        #input-section textarea:focus {
            border-color: #14b8a6; /* focus:border-teal-500 */
            box-shadow: 0 0 0 2px #14b8a6; /* focus:ring-teal-500 - focus時のリングも太く見えるように調整 */
        }
        /* 学習セクション内のテキストエリア（解答欄）のスタイル */
        #learning-section textarea.user-answer-input {
            min-height: 60px; /* 解答欄は少し小さめに */
            border-width: 1px; /* 解答欄の枠線は通常 */
            border-color: #cbd5e1; /* border-slate-300 - 通常の色 */
        }
        #learning-section textarea.user-answer-input:focus {
            border-color: #14b8a6; /* focus:border-teal-500 */
            box-shadow: 0 0 0 1px #14b8a6; /* focus:ring-teal-500 */
        }

        .main-container {
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 0.75rem; /* rounded-xl */
            margin-left: auto; /* mx-auto */
            margin-right: auto; /* mx-auto */
        }

        .message {
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            border-radius: 0.375rem; /* rounded-md */
            font-weight: 500;
            transition: opacity 0.3s ease-in-out;
        }
        .message-error { background-color: #fee2e2; color: #b91c1c; border: 1px solid #fecaca; }
        .message-warning { background-color: #ffedd5; color: #c2410c; border: 1px solid #fed7aa; }
        .message-success { background-color: #ccfbf1; color: #0f766e; border: 1px solid #99f6e4; } /* Teal系 */

        /* ボタンの共通スタイル */
        .btn {
            font-weight: 600;
            padding: 0.5rem 1rem; /* 基本のパディング */
            border-radius: 0.375rem;
            transition-property: background-color, border-color, color, box-shadow, transform;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
            font-size: 0.875rem; /* 基本のフォントサイズ (text-sm) */
            line-height: 1.25rem;
            border: 1px solid #94a3b8; /* border-slate-400 */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            cursor: pointer;
            display: inline-block;
            text-align: center;
            color: white; /* デフォルトの文字色を白に */
        }
        .btn:hover {
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow */
        }
        .btn:active {
            box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-inner */
        }
        .btn:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
        }

        /* プライマリボタン (ティール系) */
        .btn-primary {
            background-color: #14b8a6; /* bg-teal-500 */
            border-color: #0d9488; /* border-teal-600 */
        }
        .btn-primary:hover { background-color: #0d9488; }
        .btn-primary:active { background-color: #0f766e; }
        .btn-primary:focus { box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.45); }

        /* 「訳文を隠す/表示」ボタンの原文優先時 (学習中と同じティール系) */
        .btn-toggle-original-first {
            background-color: #14b8a6; /* ティール系 */
            border-color: #0d9488;
            padding: 0.75rem 1.5rem;
            font-size: 1rem; /* text-base */
            line-height: 1.5rem;
        }
        .btn-toggle-original-first:hover { background-color: #0d9488; }
        .btn-toggle-original-first:active { background-color: #0f766e; }
        .btn-toggle-original-first:focus { box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.45); }

        /* 「訳文を隠す/表示」ボタンの訳文優先時 (学習中と同じパープル系) */
        .btn-toggle-translation-first {
            background-color: #8b5cf6; /* パープル系 */
            border-color: #7c3aed;
            padding: 0.75rem 1.5rem;
            font-size: 1rem; /* text-base */
            line-height: 1.5rem;
        }
        .btn-toggle-translation-first:hover { background-color: #7c3aed; }
        .btn-toggle-translation-first:active { background-color: #6d28d9; }
        .btn-toggle-translation-first:focus { box-shadow: 0 0 0 3px rgba(192, 132, 252, 0.45); }

        /* 初期表示設定ボタン (toggle-display-priority-btn) のためのスタイル */
        .btn-display-priority-original {
            background-color: #6366f1; /* bg-indigo-500 */
            border-color: #4f46e5; /* border-indigo-600 */
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem; /* text-sm */
        }
        .btn-display-priority-original:hover { background-color: #4f46e5; }
        .btn-display-priority-original:active { background-color: #4338ca; }
        .btn-display-priority-original:focus { box-shadow: 0 0 0 3px rgba(165, 180, 252, 0.45); }

        .btn-display-priority-translation {
            background-color: #f97316; /* bg-orange-500 */
            border-color: #ea580c; /* border-orange-600 */
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem; /* text-sm */
        }
        .btn-display-priority-translation:hover { background-color: #ea580c; }
        .btn-display-priority-translation:active { background-color: #c2410c; }
        .btn-display-priority-translation:focus { box-shadow: 0 0 0 3px rgba(253, 186, 116, 0.45); }


        .btn-secondary {
            background-color: #64748b; /* bg-slate-500 */
            border-color: #475569; /* border-slate-600 */
        }
        .btn-secondary:hover { background-color: #475569; }
        .btn-secondary:active { background-color: #334155; }
        .btn-secondary:focus { box-shadow: 0 0 0 3px rgba(148, 163, 184, 0.45); }

        .btn-warning {
            background-color: #f59e0b; /* bg-amber-500 */
            border-color: #d97706; /* border-amber-600 */
        }
        .btn-warning:hover { background-color: #d97706; }
        .btn-warning:active { background-color: #b45309; }
        .btn-warning:focus { box-shadow: 0 0 0 3px rgba(252, 211, 77, 0.45); }

        .btn-info { /* 履歴表示ボタンなど */
            background-color: #38bdf8; /* bg-sky-400 */
            border-color: #0ea5e9; /* border-sky-500 */
        }
        .btn-info:hover { background-color: #0ea5e9; }
        .btn-info:active { background-color: #0284c7; }
        .btn-info:focus { box-shadow: 0 0 0 3px rgba(125, 211, 252, 0.45); }

        .btn-success { /* CSVボタンなど */
            background-color: #22c55e; /* bg-green-500 */
            border-color: #16a34a; /* border-green-600 */
        }
        .btn-success:hover { background-color: #16a34a; }
        .btn-success:active { background-color: #15803d; }
        .btn-success:focus { box-shadow: 0 0 0 3px rgba(134, 239, 172, 0.45); }

        .btn-danger { /* 履歴クリアボタンなど */
            background-color: #f43f5e; /* bg-rose-500 */
            border-color: #e11d48; /* border-rose-600 */
        }
        .btn-danger:hover { background-color: #e11d48; }
        .btn-danger:active { background-color: #be123c; }
        .btn-danger:focus { box-shadow: 0 0 0 3px rgba(253, 164, 175, 0.45); }

        .btn-small {
            padding: 0.25rem 0.75rem; /* py-1 px-3 */
            font-size: 0.75rem; /* text-xs */
            line-height: 1rem;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #e2e8f0; /* border-slate-200 */
            background-color: #f1f5f9; /* bg-slate-100 */
            color: #94a3b8; /* text-slate-400 */
        }
        .btn:disabled:hover {
            box-shadow: none;
            background-color: #f1f5f9;
        }

        ::selection {
            background-color: #5eead4; /* Tailwind teal-300 */
            color: #134e4a; /* Tailwind teal-800 */
        }
        ::-moz-selection { /* Firefox */
            background-color: #5eead4;
            color: #134e4a;
        }
        #history-items-container {
            background-color: #f1f5f9; /* bg-slate-100 */
            border-color: #e2e8f0; /* border-slate-200 */
        }
        #history-items-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
        }
        #history-items-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        .history-item:hover {
            background-color: #ccfbf1; /* bg-teal-100 (薄いティール) */
        }
        .answer-correct { color: #10b981; /* green-600 */ }
        .answer-incorrect { color: #ef4444; /* red-500 */ }
        .audio-player { width: 100%; margin-top: 0.5rem; }
    </style>
</head>
<body class="text-slate-700 flex flex-col items-center min-h-screen p-4">
    <div class="w-full max-w-3xl main-container p-6 md:p-8">
        <header class="mb-6">
            <div class="flex justify-between items-center mb-4">
                <h1 id="app-title" class="text-3xl md:text-4xl font-bold text-teal-600">多言語学習アプリ</h1>
            </div>
            <p id="app-subtitle" class="text-center text-slate-500 mt-2">長文を入力し、文ごとに学習しましょう。</p>
        </header>

        <div id="input-section" class="space-y-6 mb-8">
            <div id="mode-selection" class="mb-4">
                <h3 id="mode-select-label" class="text-lg font-medium text-slate-700 mb-2">学習モード:</h3>
                <div class="flex flex-wrap gap-2">
                    <button id="mode-memorization-btn" data-mode="memorization" class="mode-btn btn btn-sm">暗記</button>
                    <button id="mode-test-btn" data-mode="test" class="mode-btn btn btn-sm">確認</button>
                    <button id="mode-audio-btn" data-mode="audio" class="mode-btn btn btn-sm">音声</button>
                </div>
            </div>

            <div id="audio-input-container" class="hidden mb-4">
                <label for="audio-files-input" id="audio-files-label" class="block text-sm font-medium text-slate-700 mb-1">音声ファイル (学習開始前に選択):</label>
                <input type="file" id="audio-files-input" multiple accept="audio/*" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-teal-50 file:text-teal-700 hover:file:bg-teal-100">
            </div>

            <div class="flex flex-col sm:flex-row gap-2 mb-4">
                <input type="file" id="csv-file-input" accept=".csv" class="hidden">
                <button id="import-csv-btn" class="btn btn-success w-full sm:w-auto text-base">CSVから入力</button>
                <button id="export-csv-btn" class="btn btn-success w-full sm:w-auto text-base">CSVへ出力</button>
            </div>

            <div class="mt-2 mb-6 space-y-2 border-t border-b border-slate-200 py-4">
                <div class="flex flex-col sm:flex-row gap-2 items-center justify-between">
                    <h3 id="history-section-title" class="text-lg font-medium text-slate-700 self-start sm:self-center">入力履歴</h3>
                    <div class="flex gap-2 self-end sm:self-center">
                        <button id="toggle-history-btn" class="btn btn-info btn-small">履歴を表示</button>
                        <button id="clear-history-btn" class="btn btn-danger btn-small" disabled>履歴をクリア</button>
                    </div>
                </div>
                <div id="history-items-container" class="hidden max-h-60 overflow-y-auto space-y-2">
                    <p id="no-history-message" class="text-center text-slate-500 py-2">履歴はありません。</p>
                </div>
            </div>

            <div>
                <label for="original-text" id="original-text-label" class="block text-lg font-medium text-slate-700 mb-2">原文 (中国語・英語・日本語):</label>
                <textarea id="original-text" rows="4" class="w-full p-3 rounded-md shadow-sm resize-y"
                        placeholder="ここに原文の長文テキストを入力してください。文の区切りは「.」「?」「!」「。」「？」「！」です。"></textarea>
            </div>
            <div>
                <label for="translation-text" id="translation-text-label" class="block text-lg font-medium text-slate-700 mb-2">訳文 (中国語・英語・日本語):</label>
                <textarea id="translation-text" rows="4" class="w-full p-3 rounded-md shadow-sm resize-y"
                        placeholder="ここに訳文の長文テキストを入力してください。文の区切りは「.」「?」「!」「。」「？」「！」です。"></textarea>
            </div>
            <div class="flex items-center space-x-4">
                <span id="display-priority-label" class="text-sm text-slate-600">初期表示 (暗記モード):</span>
                <button id="toggle-display-priority-btn" class="btn">原文を隠す</button>
            </div>
            <div id="message-area" class="mt-4" aria-live="polite"></div>
            <div class="flex flex-col sm:flex-row gap-4">
                <button id="start-learning-btn" class="btn btn-primary w-full sm:w-auto text-base">学習開始</button>
                <button id="reset-all-btn" class="btn btn-secondary w-full sm:w-auto text-base">リセット</button>
            </div>
        </div>

        <main id="learning-section" class="hidden">
            <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
                <button id="undo-merge-btn" class="btn btn-danger" disabled>元に戻す</button>
                <button id="shuffle-pairs-btn" class="btn btn-info">ペアをシャッフル</button>
                <button id="toggle-all-translations-btn" class="btn btn-info hidden">訳文を一括表示</button>
                <button id="back-to-input-btn" class="btn btn-secondary">入力に戻る</button>
            </div>
            <div id="sentence-container" class="space-y-6">
                </div>
        </main>

        <footer class="mt-10 text-center text-sm text-slate-400">
            <p>&copy; 2025 多言語学習アプリ</p>
        </footer>
    </div>

    <script>
    // --- Global Variables & State Management ---
    let currentPairedSentences = [];
    let undoHistory = [];
    let redoHistory = [];
    const MAX_UNDO_HISTORY = 10;

    const currentLanguage = 'ja';
    let displayPriority = 'originalFirst';
    let textInputHistory = [];
    const MAX_TEXT_HISTORY_ITEMS = 20;
    const TEXT_HISTORY_STORAGE_KEY = 'multiLangAppHistory_v2';

    let currentMode = 'memorization';
    let loadedAudioFiles = [];
    let audioObjectUrls = [];
    let allTranslationsManuallyToggled = false;


    // --- i18n (Internationalization) Data ---
    const i18n = {
        ja: {
            appTitle: "多言語学習アプリ",
            appSubtitle: "長文を入力し、文ごとに学習しましょう。",
            originalTextLabel: "原文 (中国語・英語・日本語):",
            translationTextLabel: "訳文 (中国語・英語・日本語):",
            originalPlaceholder: "ここに原文の長文テキストを入力してください。文の区切りは「.」「?」「!」「。」「？」「！」です。",
            translationPlaceholder: "ここに訳文の長文テキストを入力してください。文の区切りは「.」「?」「!」「。」「？」「！」です。",
            startLearning: "学習開始",
            reset: "リセット",
            importCsv: "CSVから入力",
            exportCsv: "CSVへ出力",
            undoMerge: "元に戻す",
            showTranslation: "訳文を表示",
            hideTranslation: "訳文を隠す",
            showOriginal: "原文を表示",
            hideOriginal: "原文を隠す",
            mergeWithPreviousOriginal: "前の原文と結合",
            mergeWithPreviousTranslation: "前の訳文と結合",
            mergePairWithPrevious: "ペアごと前と結合",
            backToInput: "入力に戻る",
            displayPriorityLabel: "初期表示 (暗記モード):",
            toggleDisplayPriorityOriginalFirst: "訳文を隠す (原文優先)",
            toggleDisplayPriorityTranslationFirst: "原文を隠す (訳文優先)",
            errorBothTextsRequired: "原文と訳文の両方を入力してください。",
            errorNoValidSentences: "有効な文が見つかりませんでした。区切り文字を確認してください。",
            warningSentenceCountMismatch: (originalCount, translationCount, pairCount) => `原文 ${originalCount}件、訳文 ${translationCount}件でした。短い方の ${pairCount}件でペアを作成します。`,
            successPairsCreated: (pairCount) => `${pairCount}件のペアを作成しました。`,
            successMerged: "文を結合し、リストを更新しました。",
            successPairMerged: "ペアを結合し、リストを更新しました。",
            successReset: "入力をリセットしました。",
            successUndo: "操作を元に戻しました。",
            errorNoUndoState: "元に戻せる操作がありません。",
            noPairsToDisplay: "表示するペアがありません。",
            successCsvImported: "CSVからテキストを読み込みました。「学習開始」ボタンを押してください。",
            errorCsvFormat: "CSVファイルの形式が正しくありません。A列に原文、B列に訳文が入力されていることを確認してください。", 
            errorNoPairsToExport: "エクスポートするペアがありません。",
            delimiterRegex: /(?<=[.?!。？！])\s*/g,
            historySectionTitle: "入力履歴",
            showHistory: "履歴を表示",
            hideHistory: "履歴を隠す",
            clearHistory: "履歴をクリア",
            manualInputLabel: "手入力",
            noHistory: "履歴はありません。",
            confirmClearHistory: "本当に入力履歴をすべて削除しますか？この操作は元に戻せません。",
            historyCleared: "入力履歴をクリアしました。",
            loadedFromHistory: "履歴からテキストを読み込みました。",
            historyItemSourceLabel: "ソース: ",
            modeSelectLabel: "学習モード:",
            memorizationMode: "暗記",
            testMode: "確認",
            audioMode: "音声",
            audioFilesLabel: "音声ファイル (学習開始前に選択):",
            shufflePairs: "ペアをシャッフル",
            successShuffled: "ペアの順番をシャッフルしました。",
            enterYourAnswerPlaceholder: "ここに訳文を入力してください", // Changed placeholder
            checkAnswer: "判定",
            correctAnswerSymbol: "○",
            incorrectAnswerSymbol: "×",
            answerCorrect: "正解です！",
            answerIncorrect: "不正解です。",
            noAudioForThisPair: "このペアの音声はありません。",
            errorAudioFileAssignment: "音声ファイルの割り当てに問題が発生しました。ペアの数とファイル数が一致しないか、ファイルが選択されていません。",
            warningNotAllPairsHaveAudio: (assignedCount, totalPairs) => `音声ファイル ${assignedCount}件を ${totalPairs}件のペアに割り当てました。一部のペアには音声がない可能性があります。`,
            errorNoAudioFilesSelectedForAudioMode: "音声モードが選択されていますが、音声ファイルが読み込まれていません。「入力に戻る」からファイルを選択してください。",
            showOriginalAudio: "原文表示",
            hideOriginalAudio: "原文非表示",
            showTranslationAudio: "訳文表示",
            hideTranslationAudio: "訳文非表示",
            showAllTranslations: "訳文を一括表示",
            hideAllTranslations: "訳文を一括非表示",
        }
    };
    const t = i18n.ja;

    // --- DOM Element Retrieval ---
    const originalTextInput = document.getElementById('original-text');
    const translationTextInput = document.getElementById('translation-text');
    const startLearningBtn = document.getElementById('start-learning-btn');
    const resetAllBtn = document.getElementById('reset-all-btn');
    const sentenceContainer = document.getElementById('sentence-container');
    const inputSection = document.getElementById('input-section');
    const learningSection = document.getElementById('learning-section');
    const messageArea = document.getElementById('message-area');
    const backToInputBtn = document.getElementById('back-to-input-btn');
    const toggleDisplayPriorityBtn = document.getElementById('toggle-display-priority-btn');
    const importCsvBtn = document.getElementById('import-csv-btn');
    const exportCsvBtn = document.getElementById('export-csv-btn');
    const csvFileInput = document.getElementById('csv-file-input');
    const undoMergeBtn = document.getElementById('undo-merge-btn');
    const toggleHistoryBtn = document.getElementById('toggle-history-btn');
    const clearHistoryBtn = document.getElementById('clear-history-btn');
    const historyItemsContainer = document.getElementById('history-items-container');
    const noHistoryMessage = document.getElementById('no-history-message');

    const modeMemorizationBtn = document.getElementById('mode-memorization-btn');
    const modeTestBtn = document.getElementById('mode-test-btn');
    const modeAudioBtn = document.getElementById('mode-audio-btn');
    const modeButtons = [modeMemorizationBtn, modeTestBtn, modeAudioBtn];
    const audioInputContainer = document.getElementById('audio-input-container');
    const audioFilesInput = document.getElementById('audio-files-input');
    const shufflePairsBtn = document.getElementById('shuffle-pairs-btn');
    const toggleAllTranslationsBtn = document.getElementById('toggle-all-translations-btn');


    // --- Undo/Redo Helper Functions ---
    function saveStateForUndo() {
        undoHistory.push(JSON.parse(JSON.stringify(currentPairedSentences.map(p => ({id: p.id, original: p.original, translation: p.translation, audioSrc: p.audioSrc})))));
        if (undoHistory.length > MAX_UNDO_HISTORY) {
            undoHistory.shift();
        }
        redoHistory = [];
        updateUndoRedoButtonStates();
    }

    function updateUndoRedoButtonStates() {
        undoMergeBtn.disabled = undoHistory.length === 0;
    }

    function clearUndoRedoHistory() {
        undoHistory = [];
        redoHistory = [];
        updateUndoRedoButtonStates();
    }

    // --- UI Update Functions ---
    function updateUIText() {
        document.documentElement.lang = 'ja';
        document.title = t.appTitle;
        document.getElementById('app-title').textContent = t.appTitle;
        document.getElementById('app-subtitle').textContent = t.appSubtitle;
        document.getElementById('original-text-label').textContent = t.originalTextLabel;
        document.getElementById('translation-text-label').textContent = t.translationTextLabel;
        originalTextInput.placeholder = t.originalPlaceholder;
        translationTextInput.placeholder = t.translationPlaceholder;
        startLearningBtn.textContent = t.startLearning;
        resetAllBtn.textContent = t.reset;
        importCsvBtn.textContent = t.importCsv;
        exportCsvBtn.textContent = t.exportCsv;
        undoMergeBtn.textContent = t.undoMerge;
        backToInputBtn.textContent = t.backToInput;
        document.getElementById('display-priority-label').textContent = t.displayPriorityLabel;

        toggleDisplayPriorityBtn.textContent = displayPriority === 'originalFirst' ? t.toggleDisplayPriorityOriginalFirst : t.toggleDisplayPriorityTranslationFirst;
        toggleDisplayPriorityBtn.classList.remove('btn-display-priority-original', 'btn-display-priority-translation');
        if (displayPriority === 'originalFirst') {
            toggleDisplayPriorityBtn.classList.add('btn-display-priority-original');
        } else {
            toggleDisplayPriorityBtn.classList.add('btn-display-priority-translation');
        }

        document.getElementById('history-section-title').textContent = t.historySectionTitle;
        clearHistoryBtn.textContent = t.clearHistory;
        noHistoryMessage.textContent = t.noHistory;
        updateToggleHistoryButtonText();

        document.getElementById('mode-select-label').textContent = t.modeSelectLabel;
        modeMemorizationBtn.textContent = t.memorizationMode;
        modeTestBtn.textContent = t.testMode;
        modeAudioBtn.textContent = t.audioMode;
        document.getElementById('audio-files-label').textContent = t.audioFilesLabel;
        shufflePairsBtn.textContent = t.shufflePairs;
    }

    function updateToggleHistoryButtonText() {
        toggleHistoryBtn.textContent = historyItemsContainer.classList.contains('hidden') ? t.showHistory : t.hideHistory;
    }

    function updateModeSelectionUI() {
        modeButtons.forEach(btn => {
            if (btn.dataset.mode === currentMode) {
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
            } else {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            }
        });
        audioInputContainer.classList.toggle('hidden', currentMode !== 'audio');
        toggleAllTranslationsBtn.classList.toggle('hidden', currentMode !== 'memorization' || currentPairedSentences.length === 0);

        if (!learningSection.classList.contains('hidden') && currentPairedSentences.length > 0) {
            renderSentences();
        }
    }


    // --- Message Display Function ---
    function showMessage(text, type = 'error', isKey = false, duration = 3000) {
        messageArea.innerHTML = '';
        const messageDiv = document.createElement('div');
        const messageText = isKey ? (t[text] || text) : text;
        
        messageDiv.textContent = typeof messageText === 'function' ? messageText() : messageText;
        messageDiv.className = `message message-${type}`;
        messageArea.appendChild(messageDiv);

        if (type === 'success' || type === 'warning') {
            setTimeout(() => {
                if (messageArea.contains(messageDiv)) {
                    messageArea.removeChild(messageDiv);
                }
            }, duration);
        }
    }

    // --- Text Splitting Function ---
    function splitTextIntoSentences(text) {
        if (!text || !text.trim()) return [];
        const delimiterRegex = t.delimiterRegex;
        return text.split(delimiterRegex)
                .map(s => s.trim())
                .filter(s => s.length > 0);
    }

    // --- Audio File Handling ---
    function revokePreviousAudioUrls() {
        audioObjectUrls.forEach(url => URL.revokeObjectURL(url));
        audioObjectUrls = [];
    }

    audioFilesInput.addEventListener('change', (event) => {
        revokePreviousAudioUrls();
        loadedAudioFiles = Array.from(event.target.files).map(file => {
            const url = URL.createObjectURL(file);
            audioObjectUrls.push(url);
            return { file, url };
        });
        if (loadedAudioFiles.length > 0) {
            showMessage(`${loadedAudioFiles.length}件の音声ファイルを選択しました。`, "success");
        }
    });
    
    // --- Text Input History Functions ---
    function loadTextInputHistoryFromStorage() {
        const storedHistory = localStorage.getItem(TEXT_HISTORY_STORAGE_KEY);
        if (storedHistory) {
            try {
                textInputHistory = JSON.parse(storedHistory);
            } catch (e) {
                console.error("Error parsing text input history from localStorage:", e);
                textInputHistory = [];
            }
        }
    }

    function saveTextInputHistoryToStorage() {
        localStorage.setItem(TEXT_HISTORY_STORAGE_KEY, JSON.stringify(textInputHistory));
    }

    function addEntryToTextInputHistory(original, translation, sourceFilename) {
        const newSource = sourceFilename || t.manualInputLabel;
        if (textInputHistory.length > 0) {
            const lastEntry = textInputHistory[0];
            if (lastEntry.original === original &&
                lastEntry.translation === translation &&
                lastEntry.source === newSource) {
                textInputHistory.shift(); 
            }
        }
        const newEntry = {
            id: `hist-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
            original: original,
            translation: translation,
            source: newSource,
            timestamp: new Date().toISOString()
        };
        textInputHistory.unshift(newEntry);
        if (textInputHistory.length > MAX_TEXT_HISTORY_ITEMS) {
            textInputHistory.pop();
        }
        saveTextInputHistoryToStorage();
        renderTextInputHistoryList();
    }

    function renderTextInputHistoryList() {
        const dynamicItems = historyItemsContainer.querySelectorAll('div[role="button"]');
        dynamicItems.forEach(item => item.remove());

        if (textInputHistory.length === 0) {
            noHistoryMessage.style.display = 'block';
            clearHistoryBtn.disabled = true;
            return;
        }
        noHistoryMessage.style.display = 'none';
        clearHistoryBtn.disabled = false;

        const fragment = document.createDocumentFragment();
        textInputHistory.forEach(entry => {
            const historyEntryDiv = document.createElement('div');
            historyEntryDiv.className = 'history-item p-3 bg-white border border-slate-300 rounded-md hover:bg-teal-50 cursor-pointer transition-colors focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-75';
            historyEntryDiv.setAttribute('role', 'button');
            historyEntryDiv.tabIndex = 0;
            historyEntryDiv.dataset.historyId = entry.id;

            const sourceDisplay = entry.source === t.manualInputLabel ? t.manualInputLabel : `${t.historyItemSourceLabel}${entry.source}`;
            const snippet = entry.original.substring(0, 70) + (entry.original.length > 70 ? '...' : '');

            historyEntryDiv.innerHTML = `
                <p class="text-xs text-slate-400">${new Date(entry.timestamp).toLocaleString('ja-JP')}</p>
                <p class="font-medium text-sm text-teal-600">${sourceDisplay}</p>
                <p class="text-sm text-slate-600 break-all" title="${entry.original.substring(0,200)}...">${snippet}</p>
            `;
            historyEntryDiv.addEventListener('click', () => loadTextInputHistoryEntry(entry.id));
            historyEntryDiv.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    loadTextInputHistoryEntry(entry.id);
                }
            });
            fragment.appendChild(historyEntryDiv);
        });
        historyItemsContainer.appendChild(fragment);
    }

    function loadTextInputHistoryEntry(entryId) {
        const entry = textInputHistory.find(item => item.id === entryId);
        if (entry) {
            originalTextInput.value = entry.original;
            translationTextInput.value = entry.translation;
            showMessage(t.loadedFromHistory, "success", true);
            
            currentPairedSentences = [];
            clearUndoRedoHistory();
            sentenceContainer.innerHTML = '';
            updateUndoRedoButtonStates();

            if (!learningSection.classList.contains('hidden')) {
                learningSection.classList.add('hidden');
                inputSection.classList.remove('hidden');
            }
            originalTextInput.focus();
        }
    }

    // --- Learning Content Rendering Function ---
    function normalizeAnswerForComparison(answer) {
        let normalized = String(answer || '').trim();
        if (normalized.endsWith('。') || normalized.endsWith('.')) {
            normalized = normalized.slice(0, -1);
        }
        normalized = normalized.replace(/\s+/g, '').replace(/　+/g, '');
        return normalized.trim();
    }

    function renderSentences() {
        sentenceContainer.innerHTML = '';
        if (toggleAllTranslationsBtn) { 
            toggleAllTranslationsBtn.classList.toggle('hidden', currentMode !== 'memorization' || currentPairedSentences.length === 0);
        }

        if (currentPairedSentences.length === 0) {
            showMessage("noPairsToDisplay", "warning", true);
            updateUndoRedoButtonStates();
            return;
        }
        
        if (currentMode === 'memorization' && toggleAllTranslationsBtn) {
            toggleAllTranslationsBtn.textContent = allTranslationsManuallyToggled ? t.hideAllTranslations : t.showAllTranslations;
        }

        currentPairedSentences.forEach((sentenceData, index) => {
            const pairDiv = document.createElement('div');
            pairDiv.className = 'sentence-pair p-5 border border-slate-200 rounded-lg bg-white hover:shadow-lg transition-shadow duration-300';
            pairDiv.dataset.id = sentenceData.id; 

            const originalPara = document.createElement('p');
            originalPara.className = 'original-sentence text-xl font-semibold text-slate-800 mb-2 break-words';
            originalPara.textContent = sentenceData.original;

            const translationPara = document.createElement('p');
            translationPara.className = 'translation-sentence text-lg text-slate-700 p-3 bg-teal-50 border border-teal-200 rounded-md mt-2 break-words';
            translationPara.textContent = sentenceData.translation;

            if (currentMode === 'memorization') {
                const toggleBtn = document.createElement('button');
                toggleBtn.dataset.pairId = sentenceData.id; 
                let toggleBtnClasses = 'btn mt-2 mb-3 individual-toggle-btn ';

                if (displayPriority === 'originalFirst') {
                    toggleBtnClasses += 'btn-toggle-original-first';
                    translationPara.classList.toggle('hidden', !allTranslationsManuallyToggled);
                    toggleBtn.textContent = allTranslationsManuallyToggled ? t.hideTranslation : t.showTranslation;
                } else { 
                    toggleBtnClasses += 'btn-toggle-translation-first';
                    originalPara.classList.toggle('hidden', !allTranslationsManuallyToggled);
                    toggleBtn.textContent = allTranslationsManuallyToggled ? t.hideOriginal : t.showOriginal;
                }
                toggleBtn.className = toggleBtnClasses;
                toggleBtn.addEventListener('click', () => {
                    if (displayPriority === 'originalFirst') {
                        translationPara.classList.toggle('hidden');
                        toggleBtn.textContent = translationPara.classList.contains('hidden') ? t.showTranslation : t.hideTranslation;
                    } else {
                        originalPara.classList.toggle('hidden');
                        toggleBtn.textContent = originalPara.classList.contains('hidden') ? t.showOriginal : t.hideOriginal;
                    }
                    
                    let allCurrentlyShown = true;
                    document.querySelectorAll('.sentence-pair').forEach(pDiv => {
                        const individualToggle = pDiv.querySelector('.individual-toggle-btn');
                        if (individualToggle) { 
                            if (displayPriority === 'originalFirst') {
                                if (pDiv.querySelector('.translation-sentence').classList.contains('hidden')) allCurrentlyShown = false;
                            } else {
                                if (pDiv.querySelector('.original-sentence').classList.contains('hidden')) allCurrentlyShown = false;
                            }
                        }
                    });
                    allTranslationsManuallyToggled = allCurrentlyShown; 
                    if (toggleAllTranslationsBtn) {
                        toggleAllTranslationsBtn.textContent = allTranslationsManuallyToggled ? t.hideAllTranslations : t.showAllTranslations;
                    }
                });

                if (displayPriority === 'originalFirst') {
                    pairDiv.appendChild(originalPara);
                    pairDiv.appendChild(toggleBtn);
                    pairDiv.appendChild(translationPara);
                } else {
                    pairDiv.appendChild(translationPara);
                    pairDiv.appendChild(toggleBtn);
                    pairDiv.appendChild(originalPara);
                }
            } else if (currentMode === 'test') {
                originalPara.classList.remove('hidden');
                translationPara.classList.add('hidden');
                const testArea = document.createElement('div');
                testArea.className = 'test-area mt-3 space-y-2';
                const userAnswerInput = document.createElement('textarea');
                userAnswerInput.className = 'user-answer-input w-full p-2 border border-slate-300 rounded-md resize-y'; // Standard border
                userAnswerInput.rows = 2;
                userAnswerInput.placeholder = t.enterYourAnswerPlaceholder; // Updated placeholder
                const checkAnswerBtn = document.createElement('button');
                checkAnswerBtn.className = 'check-answer-btn btn btn-primary btn-small';
                checkAnswerBtn.textContent = t.checkAnswer;
                const answerResultDiv = document.createElement('div');
                answerResultDiv.className = 'answer-result text-lg font-bold mt-1';
                checkAnswerBtn.addEventListener('click', () => {
                    const userAnswer = userAnswerInput.value; 
                    const correctAnswer = sentenceData.translation;
                    const normalizedUserAnswer = normalizeAnswerForComparison(userAnswer);
                    const normalizedCorrectAnswer = normalizeAnswerForComparison(correctAnswer);
                    if (normalizedUserAnswer.toLowerCase() === normalizedCorrectAnswer.toLowerCase()) {
                        answerResultDiv.textContent = `${t.correctAnswerSymbol} ${t.answerCorrect}`;
                        answerResultDiv.className = 'answer-result text-lg font-bold mt-1 answer-correct';
                    } else {
                        answerResultDiv.textContent = `${t.incorrectAnswerSymbol} ${t.answerIncorrect}`;
                        answerResultDiv.className = 'answer-result text-lg font-bold mt-1 answer-incorrect';
                    }
                    translationPara.classList.remove('hidden');
                    checkAnswerBtn.disabled = true;
                });
                pairDiv.appendChild(originalPara);
                testArea.appendChild(userAnswerInput);
                testArea.appendChild(checkAnswerBtn);
                testArea.appendChild(answerResultDiv);
                pairDiv.appendChild(testArea);
                pairDiv.appendChild(translationPara); 
            } else if (currentMode === 'audio') {
                originalPara.classList.add('hidden'); 
                translationPara.classList.add('hidden');
                const audioControlsDiv = document.createElement('div');
                audioControlsDiv.className = 'audio-controls my-3 space-y-2';
                if (sentenceData.audioSrc) { 
                    const audioPlayer = document.createElement('audio');
                    audioPlayer.className = 'audio-player';
                    audioPlayer.controls = true;
                    audioPlayer.src = sentenceData.audioSrc;
                    audioControlsDiv.appendChild(audioPlayer);
                } else { 
                    const noAudioMsg = document.createElement('p');
                    noAudioMsg.className = 'text-sm text-slate-500';
                    noAudioMsg.textContent = t.noAudioForThisPair;
                    audioControlsDiv.appendChild(noAudioMsg);
                }
                const showOriginalBtn = document.createElement('button');
                showOriginalBtn.className = 'btn btn-secondary btn-small mr-2';
                showOriginalBtn.textContent = t.showOriginalAudio;
                showOriginalBtn.addEventListener('click', () => {
                    originalPara.classList.toggle('hidden');
                    showOriginalBtn.textContent = originalPara.classList.contains('hidden') ? t.showOriginalAudio : t.hideOriginalAudio;
                });
                const showTranslationBtn = document.createElement('button');
                showTranslationBtn.className = 'btn btn-secondary btn-small';
                showTranslationBtn.textContent = t.showTranslationAudio;
                showTranslationBtn.addEventListener('click', () => {
                    translationPara.classList.toggle('hidden');
                    showTranslationBtn.textContent = translationPara.classList.contains('hidden') ? t.showTranslationAudio : t.hideTranslationAudio;
                });
                audioControlsDiv.appendChild(showOriginalBtn);
                audioControlsDiv.appendChild(showTranslationBtn);
                pairDiv.appendChild(audioControlsDiv);
                pairDiv.appendChild(originalPara); 
                const testArea = document.createElement('div');
                testArea.className = 'test-area mt-3 space-y-2';
                const userAnswerInput = document.createElement('textarea');
                userAnswerInput.className = 'user-answer-input w-full p-2 border border-slate-300 rounded-md resize-y'; // Standard border
                userAnswerInput.rows = 2;
                userAnswerInput.placeholder = t.enterYourAnswerPlaceholder; // Updated placeholder
                const checkAnswerBtn = document.createElement('button');
                checkAnswerBtn.className = 'check-answer-btn btn btn-primary btn-small';
                checkAnswerBtn.textContent = t.checkAnswer;
                const answerResultDiv = document.createElement('div');
                answerResultDiv.className = 'answer-result text-lg font-bold mt-1';
                checkAnswerBtn.addEventListener('click', () => {
                    const userAnswer = userAnswerInput.value; 
                    const correctAnswer = sentenceData.translation; 
                    const normalizedUserAnswer = normalizeAnswerForComparison(userAnswer);
                    const normalizedCorrectAnswer = normalizeAnswerForComparison(correctAnswer);
                    if (normalizedUserAnswer.toLowerCase() === normalizedCorrectAnswer.toLowerCase()) {
                        answerResultDiv.textContent = `${t.correctAnswerSymbol} ${t.answerCorrect}`;
                        answerResultDiv.className = 'answer-result text-lg font-bold mt-1 answer-correct';
                    } else {
                        answerResultDiv.textContent = `${t.incorrectAnswerSymbol} ${t.answerIncorrect}`;
                        answerResultDiv.className = 'answer-result text-lg font-bold mt-1 answer-incorrect';
                    }
                    translationPara.classList.remove('hidden'); 
                    showTranslationBtn.textContent = t.hideTranslationAudio; 
                    checkAnswerBtn.disabled = true;
                });
                testArea.appendChild(userAnswerInput);
                testArea.appendChild(checkAnswerBtn);
                testArea.appendChild(answerResultDiv);
                pairDiv.appendChild(testArea);
                pairDiv.appendChild(translationPara); 
            }

            if (index > 0) {
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'mt-3 border-t border-slate-200 pt-3 flex flex-wrap gap-2 justify-start';
                const mergeOriginalBtn = document.createElement('button');
                mergeOriginalBtn.className = 'btn btn-warning btn-small';
                mergeOriginalBtn.textContent = t.mergeWithPreviousOriginal;
                mergeOriginalBtn.dataset.index = index;
                mergeOriginalBtn.dataset.type = 'original';
                mergeOriginalBtn.addEventListener('click', handleMergeWithPrevious);
                const mergeTranslationBtn = document.createElement('button');
                mergeTranslationBtn.className = 'btn btn-warning btn-small';
                mergeTranslationBtn.textContent = t.mergeWithPreviousTranslation;
                mergeTranslationBtn.dataset.index = index;
                mergeTranslationBtn.dataset.type = 'translation';
                mergeTranslationBtn.addEventListener('click', handleMergeWithPrevious);
                const mergePairBtn = document.createElement('button');
                mergePairBtn.className = 'btn btn-info btn-small';
                mergePairBtn.textContent = t.mergePairWithPrevious;
                mergePairBtn.dataset.index = index;
                mergePairBtn.dataset.type = 'full_pair';
                mergePairBtn.addEventListener('click', handleMergeWithPrevious);
                buttonContainer.appendChild(mergeOriginalBtn);
                buttonContainer.appendChild(mergeTranslationBtn);
                buttonContainer.appendChild(mergePairBtn);
                pairDiv.appendChild(buttonContainer);
            }
            sentenceContainer.appendChild(pairDiv);
        });
        updateUndoRedoButtonStates();
    }
    

    // --- Event Listeners ---
    modeButtons.forEach(button => {
        button.addEventListener('click', () => {
            currentMode = button.dataset.mode;
            allTranslationsManuallyToggled = false; 
            updateModeSelectionUI();
        });
    });

    toggleDisplayPriorityBtn.addEventListener('click', () => {
        displayPriority = displayPriority === 'originalFirst' ? 'translationFirst' : 'originalFirst';
        allTranslationsManuallyToggled = false; 
        updateUIText();
        if (!learningSection.classList.contains('hidden') && currentPairedSentences.length > 0 && currentMode === 'memorization') {
            renderSentences();
        }
    });

    startLearningBtn.addEventListener('click', () => {
        messageArea.innerHTML = '';
        const originalText = originalTextInput.value;
        const translationText = translationTextInput.value;

        if (!originalText.trim() && !translationText.trim()) {
            showMessage("errorBothTextsRequired", "error", true);
            return;
        }
        
        addEntryToTextInputHistory(originalText, translationText, null);

        const originalSentences = splitTextIntoSentences(originalText);
        const translationSentences = splitTextIntoSentences(translationText);

        if (originalSentences.length === 0 || translationSentences.length === 0) {
            showMessage("errorNoValidSentences", "error", true);
            return;
        }
        
        currentPairedSentences = [];
        clearUndoRedoHistory();
        allTranslationsManuallyToggled = false; 

        const pairCount = Math.min(originalSentences.length, translationSentences.length);

        if (originalSentences.length !== translationSentences.length) {
            showMessage(t.warningSentenceCountMismatch(originalSentences.length, translationSentences.length, pairCount), "warning");
        } else {
            showMessage(t.successPairsCreated(pairCount), "success");
        }

        let audioAssignedCount = 0;
        for (let i = 0; i < pairCount; i++) {
            let audioSrc = null;
            if (currentMode === 'audio' && loadedAudioFiles[i]) {
                audioSrc = loadedAudioFiles[i].url;
                audioAssignedCount++;
            }
            currentPairedSentences.push({
                id: `s-${Date.now()}-${i}`,
                original: originalSentences[i],
                translation: translationSentences[i],
                audioSrc: audioSrc
            });
        }

        if (currentMode === 'audio') {
            if (loadedAudioFiles.length === 0 && pairCount > 0) {
                showMessage("errorNoAudioFilesSelectedForAudioMode", "warning", true, 5000);
            } else if (audioAssignedCount < pairCount && pairCount > 0) {
                showMessage(t.warningNotAllPairsHaveAudio(audioAssignedCount, pairCount), "warning", false, 5000);
            }
        }
        
        inputSection.classList.add('hidden');
        learningSection.classList.remove('hidden'); 
        updateModeSelectionUI(); 
        
        window.scrollTo(0,0);
    });

    function handleMergeWithPrevious(event) {
        const currentIndex = parseInt(event.target.dataset.index, 10);
        const type = event.target.dataset.type;

        if (currentIndex > 0 && currentIndex < currentPairedSentences.length) {
            saveStateForUndo();

            const previousPair = currentPairedSentences[currentIndex - 1];
            const currentMergingPair = currentPairedSentences[currentIndex];
            let messageKey = "";

            if (type === 'original') {
                previousPair.original = (previousPair.original + " " + currentMergingPair.original).trim();
                for (let i = currentIndex; i < currentPairedSentences.length - 1; i++) {
                    currentPairedSentences[i].original = currentPairedSentences[i + 1].original;
                }
                if (currentPairedSentences.length > currentIndex) {
                    currentPairedSentences[currentPairedSentences.length - 1].original = "";
                }
                messageKey = "successMerged";
            } else if (type === 'translation') {
                previousPair.translation = (previousPair.translation + " " + currentMergingPair.translation).trim();
                for (let i = currentIndex; i < currentPairedSentences.length - 1; i++) {
                    currentPairedSentences[i].translation = currentPairedSentences[i + 1].translation;
                }
                if (currentPairedSentences.length > currentIndex) {
                    currentPairedSentences[currentPairedSentences.length - 1].translation = "";
                }
                messageKey = "successMerged";
            } else if (type === 'full_pair') {
                previousPair.original = (previousPair.original + " " + currentMergingPair.original).trim();
                previousPair.translation = (previousPair.translation + " " + currentMergingPair.translation).trim();
                if (!previousPair.audioSrc && currentMergingPair.audioSrc) {
                    previousPair.audioSrc = currentMergingPair.audioSrc;
                }
                currentPairedSentences.splice(currentIndex, 1);
                messageKey = "successPairMerged";
            }
            
            if (type === 'original' || type === 'translation') {
                if (currentPairedSentences.length > 0) {
                    const lastPairIndex = currentPairedSentences.length - 1;
                    if (currentPairedSentences[lastPairIndex].original === "" && currentPairedSentences[lastPairIndex].translation === "") {
                        currentPairedSentences.splice(lastPairIndex, 1);
                    }
                }
            }
            
            renderSentences();
            showMessage(messageKey, "success", true);
        }
    }
    
    undoMergeBtn.addEventListener('click', () => {
        if (undoHistory.length > 0) {
            redoHistory.push(JSON.parse(JSON.stringify(currentPairedSentences.map(p => ({id: p.id, original: p.original, translation: p.translation, audioSrc: p.audioSrc})))));
            currentPairedSentences = undoHistory.pop();
            allTranslationsManuallyToggled = false; 
            renderSentences();
            showMessage("successUndo", "success", true);
            updateUndoRedoButtonStates();
        } else {
            showMessage("errorNoUndoState", "warning", true);
        }
    });

    shufflePairsBtn.addEventListener('click', () => {
        if (currentPairedSentences.length > 1) {
            saveStateForUndo();
            for (let i = currentPairedSentences.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentPairedSentences[i], currentPairedSentences[j]] = [currentPairedSentences[j], currentPairedSentences[i]];
            }
            allTranslationsManuallyToggled = false; 
            renderSentences();
            showMessage(t.successShuffled, "success", true);
        }
    });

    toggleAllTranslationsBtn.addEventListener('click', () => {
        if (currentMode !== 'memorization' || currentPairedSentences.length === 0) return;

        allTranslationsManuallyToggled = !allTranslationsManuallyToggled; 

        currentPairedSentences.forEach(pair => {
            const pairDiv = sentenceContainer.querySelector(`.sentence-pair[data-id="${pair.id}"]`);
            if (!pairDiv) return;

            const originalEl = pairDiv.querySelector('.original-sentence');
            const translationEl = pairDiv.querySelector('.translation-sentence');
            const individualToggleBtn = pairDiv.querySelector('.individual-toggle-btn');

            if (displayPriority === 'originalFirst') {
                translationEl.classList.toggle('hidden', !allTranslationsManuallyToggled);
                if (individualToggleBtn) individualToggleBtn.textContent = allTranslationsManuallyToggled ? t.hideTranslation : t.showTranslation;
            } else { 
                originalEl.classList.toggle('hidden', !allTranslationsManuallyToggled);
                if (individualToggleBtn) individualToggleBtn.textContent = allTranslationsManuallyToggled ? t.hideOriginal : t.showOriginal;
            }
        });
        if (toggleAllTranslationsBtn) {
            toggleAllTranslationsBtn.textContent = allTranslationsManuallyToggled ? t.hideAllTranslations : t.showAllTranslations;
        }
    });


    resetAllBtn.addEventListener('click', () => {
        originalTextInput.value = '';
        translationTextInput.value = '';
        currentPairedSentences = [];
        clearUndoRedoHistory();
        revokePreviousAudioUrls();
        loadedAudioFiles = [];
        audioFilesInput.value = '';
        sentenceContainer.innerHTML = '';
        learningSection.classList.add('hidden');
        inputSection.classList.remove('hidden');
        messageArea.innerHTML = '';
        allTranslationsManuallyToggled = false;
        showMessage("successReset", "success", true);
        originalTextInput.focus();
    });

    backToInputBtn.addEventListener('click', () => {
        learningSection.classList.add('hidden');
        inputSection.classList.remove('hidden');
        messageArea.innerHTML = '';
        allTranslationsManuallyToggled = false; 
        originalTextInput.focus();
    });
    
    toggleHistoryBtn.addEventListener('click', () => {
        historyItemsContainer.classList.toggle('hidden');
        updateToggleHistoryButtonText();
    });

    clearHistoryBtn.addEventListener('click', () => {
        if (textInputHistory.length > 0 && confirm(t.confirmClearHistory)) {
            textInputHistory = [];
            saveTextInputHistoryToStorage();
            renderTextInputHistoryList();
            showMessage(t.historyCleared, "success", true);
        }
    });

    importCsvBtn.addEventListener('click', () => {
        csvFileInput.click();
    });

    /**
     * Parses a CSV text string into an array of records (rows), where each record is an array of fields (cells).
     * Handles quoted fields containing commas, newlines, and escaped double quotes ("").
     * @param {string} csvText The raw CSV text.
     * @returns {string[][]} An array of rows, where each row is an array of cell strings.
     */
    function parseCSVText_custom(csvText) {
        const records = [];
        let currentRecord = [];
        let currentField = "";
        let inQuotes = false;

        const normalizedText = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

        for (let i = 0; i < normalizedText.length; i++) {
            const char = normalizedText[i];

            if (inQuotes) {
                if (char === '"') {
                    if (i + 1 < normalizedText.length && normalizedText[i + 1] === '"') {
                        currentField += '"';
                        i++; 
                    } else {
                        inQuotes = false; 
                    }
                } else {
                    currentField += char; 
                }
            } else { 
                if (char === '"') {
                    inQuotes = true;
                    if (currentField.length > 0) {
                        // This indicates an unquoted field ended right before a quote, which is unusual.
                        // Standard CSV parsers might treat this quote literally or as an error.
                        // For simplicity, we will treat the existing currentField as a complete field.
                        // currentRecord.push(currentField); 
                        // currentField = ""; 
                        // The line above would be one way, but it's better to assume quotes start a field or are escaped.
                        // If a quote appears outside a quoted field and currentField is not empty,
                        // it's likely part of the data. Let's assume this simple parser
                        // expects quotes to either fully enclose a field or be escaped within one.
                        // If a field starts with a quote, it must end with one.
                        // If currentField is empty, this is the start of a quoted field.
                    }
                } else if (char === ',') {
                    currentRecord.push(currentField);
                    currentField = "";
                } else if (char === '\n') {
                    currentRecord.push(currentField); 
                    records.push([...currentRecord]); 
                    currentRecord = []; 
                    currentField = "";
                } else {
                    currentField += char;
                }
            }
        }
        currentRecord.push(currentField);
        if (currentRecord.some(f => f.length > 0) || (records.length === 0 && currentRecord.length > 0) ) {
            records.push([...currentRecord]);
        }
        
        return records.filter(record => record.length > 0 && record.some(field => field.trim() !== ""));
    }


    csvFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const csvText = e.target.result;
                try {
                    const parsedRows = parseCSVText_custom(csvText);
                    
                    if (parsedRows.length > 0) {
                        let originalTextParts = [];
                        let translationTextParts = [];

                        parsedRows.forEach(rowCells => {
                            let cellA = rowCells.length > 0 ? rowCells[0] : "";
                            let cellB = rowCells.length > 1 ? rowCells[1] : "";
                            
                            // Replace literal "\\n" with actual newline characters
                            cellA = cellA.replace(/\\n/g, '\n');
                            cellB = cellB.replace(/\\n/g, '\n');

                            if (cellA.trim()) { // Add only if cell A has content after trim
                                originalTextParts.push(cellA.trim());
                            }
                            // Add cell B content if cell A had content, even if B is empty, to maintain pairing
                            if (cellA.trim()) {
                                translationTextParts.push(cellB.trim());
                            }
                        });
                        
                        // Join original parts, ensuring each ends with "。"
                        const finalOriginalText = originalTextParts
                            .map(p => p.replace(/[.。？！]$/, "") + "。")
                            .join(""); 

                        // Join translation parts, ensuring each ends with "." and parts are space-separated
                        const finalTranslationText = translationTextParts
                            .map(p => {
                                if (!p) return "."; // If part is empty, just a period.
                                return p.replace(/[.。？！]$/, "") + ".";
                            })
                            .join(" ")
                            .replace(/\s+\.\s*/g, ". ") // Clean up: " . " -> ". "
                            .trim();


                        originalTextInput.value = finalOriginalText;
                        translationTextInput.value = finalTranslationText;

                        if (finalOriginalText || finalTranslationText) {
                            showMessage("successCsvImported", "success", true);
                            addEntryToTextInputHistory(finalOriginalText, finalTranslationText, file.name);
                            clearUndoRedoHistory();
                            updateUndoRedoButtonStates();
                        } else {
                            showMessage(t.errorCsvFormat, "error", true);
                        }
                    } else {
                        showMessage(t.errorCsvFormat, "error", true); 
                    }
                } catch (err) {
                    showMessage(t.errorCsvFormat, "error", true);
                    console.error("CSV Parse Error:", err);
                }
            };
            reader.readAsText(file, 'UTF-8');
            csvFileInput.value = '';
        }
    });

    exportCsvBtn.addEventListener('click', () => {
        if (currentPairedSentences.length === 0) {
            showMessage("errorNoPairsToExport", "warning", true);
            return;
        }
        let csvContent = '"Original","Translation"\n';
        currentPairedSentences.forEach(pair => {
            const original = `"${pair.original.replace(/"/g, '""')}"`;
            const translation = `"${pair.translation.replace(/"/g, '""')}"`;
            csvContent += `${original},${translation}\n`;
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        if (link.download !== undefined) {
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "learned_pairs.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        } else {
            showMessage("CSV export might not be fully supported on this browser.", "warning");
        }
    });

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        loadTextInputHistoryFromStorage();
        updateUIText();
        updateUndoRedoButtonStates();
        renderTextInputHistoryList();
        updateModeSelectionUI();
    });

    window.addEventListener('beforeunload', () => {
        revokePreviousAudioUrls();
    });

    </script>
</body>
</html>
