<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多言語学習アプリ</title>
    <link rel="manifest" href="./manifest.json" />
    <meta name="theme-color" content="#14b8a6" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary-light: #f0fdfa; /* teal-50 */
            --bg-primary-dark: #ccfbf1;  /* teal-100 */
            --text-primary: #1f2937; /* gray-800 */
            --text-secondary: #4b5563; /* gray-600 */
            --text-accent: #0d9488; /* teal-600 */
            --text-accent-strong: #0f766e; /* teal-700 */
            --container-bg: rgba(255, 255, 255, 0.85); /* semi-transparent white */
            --container-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --input-border: #9ca3af; /* gray-400 */
            --input-focus-border: var(--text-accent);
            --input-focus-ring: var(--text-accent);
            --history-item-bg: #f9fafb; /* gray-50 */
            --history-item-border: #e5e7eb; /* gray-200 */
            --history-item-hover-bg: #f0fdfa; /* teal-50 */
            --scrollbar-thumb: #a7f3d0; /* teal-200 */
            --scrollbar-thumb-hover: #6ee7b7; /* teal-300 */
            --selection-bg: #5eead4;
            --selection-text: #134e4a;
            --btn-primary-bg: var(--text-accent);
            --btn-primary-border: var(--text-accent-strong);
            --btn-primary-hover-bg: var(--text-accent-strong);
            --btn-primary-active-bg: #047857; /* teal-800 */
            --btn-primary-focus-ring: rgba(13, 148, 136, 0.45);
            --btn-text-color: white;

            --sidebar-bg: rgba(255, 255, 255, 0.95);
            --sidebar-border: #e5e7eb; /* gray-200 */
            --sidebar-text: var(--text-primary);
            --sidebar-item-hover-bg: #f0fdfa; /* teal-50 */
            --sidebar-item-active-bg: #ccfbf1; /* teal-100 */
            --sidebar-item-active-text: var(--text-accent-strong);
            --sidebar-item-active-border: var(--text-accent-strong);
            --sidebar-shadow: 0 0 20px rgba(0,0,0,0.1);
            --sidebar-width: 280px;

            /* Message specific colors */
            --message-error-bg: #fee2e2; /* red-100 */
            --message-error-text: #991b1b; /* red-800 */
            --message-error-border: #fca5a5; /* red-300 */
            --message-warning-bg: #ffedd5; /* orange-100 */
            --message-warning-text: #9a3412; /* orange-800 */
            --message-warning-border: #fdba74; /* orange-300 */
            --message-success-bg: #dcfce7; /* green-100 */
            --message-success-text: #166534; /* green-800 */
            --message-success-border: #86efac; /* green-300 */
            --message-info-bg: #e0f2fe; /* sky-100 */
            --message-info-text: #075985; /* sky-800 */
            --message-info-border: #7dd3fc; /* sky-300 */

             /* Sentence pair specific colors */
            --sentence-pair-bg: var(--container-bg);
            --sentence-pair-border: var(--input-border);
            --original-sentence-text: var(--text-primary);
            --translation-sentence-bg: var(--bg-primary-light);
            --translation-sentence-text: var(--text-secondary);
            --translation-sentence-border: var(--input-border);
        }

        html.dark {
            --bg-primary-light: #111827; /* gray-900 */
            --bg-primary-dark: #1f2937;  /* gray-800 */
            --text-primary: #f3f4f6; /* gray-100 */
            --text-secondary: #d1d5db; /* gray-300 */
            --text-accent: #2dd4bf; /* teal-400 */
            --text-accent-strong: #14b8a6; /* teal-500 */
            --container-bg: rgba(31, 41, 55, 0.85); /* slate-800 semi-transparent */
            --container-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.15), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            --input-border: #4b5563; /* gray-600 */
            --input-focus-border: var(--text-accent);
            --input-focus-ring: var(--text-accent);
            --history-item-bg: #374151; /* gray-700 */
            --history-item-border: #4b5563; /* gray-600 */
            --history-item-hover-bg: #0f766e; /* teal-700 */
            --scrollbar-thumb: #374151;
            --scrollbar-thumb-hover: #4b5563;
            --selection-bg: var(--text-accent);
            --selection-text: #064e3b; /* teal-900 */
            --btn-primary-bg: var(--text-accent);
            --btn-primary-border: #0d9488;
            --btn-primary-hover-bg: #0d9488;
            --btn-primary-active-bg: #0f766e;
            --btn-primary-focus-ring: rgba(45, 212, 191, 0.45);

            --sidebar-bg: rgba(17, 24, 39, 0.95); /* gray-900 semi-transparent */
            --sidebar-border: #374151; /* gray-700 */
            --sidebar-text: var(--text-primary);
            --sidebar-item-hover-bg: #1f2937; /* gray-800 */
            --sidebar-item-active-bg: #0f766e; /* teal-700 */
            --sidebar-item-active-text: #f0fdfa; /* teal-50 for dark active text */
            --sidebar-item-active-border: var(--text-accent);
            --sidebar-shadow: 0 0 20px rgba(0,0,0,0.3);

            /* Message specific colors - Dark */
            --message-error-bg: #450a0a; /* red-900 adjusted */
            --message-error-text: #fecaca; /* red-200 */
            --message-error-border: #7f1d1d; /* red-700 */
            --message-warning-bg: #4a2c0d; /* orange-900 adjusted */
            --message-warning-text: #fed7aa; /* orange-200 */
            --message-warning-border: #9a3412; /* orange-700 */
            --message-success-bg: #0d3d1f; /* green-900 adjusted */
            --message-success-text: #bbf7d0; /* green-200 */
            --message-success-border: #15803d; /* green-700 */
            --message-info-bg: #0c395e; /* sky-900 adjusted */
            --message-info-text: #bae6fd; /* sky-200 */
            --message-info-border: #0369a1; /* sky-700 */

            /* Sentence pair specific colors - Dark */
            --sentence-pair-bg: var(--container-bg);
            --sentence-pair-border: var(--input-border);
            --original-sentence-text: var(--text-primary);
            --translation-sentence-bg: var(--bg-primary-dark); /* Slightly darker than main bg for contrast */
            --translation-sentence-text: var(--text-secondary);
            --translation-sentence-border: var(--input-border);
        }

        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s, color 0.3s;
            -webkit-overflow-scrolling: touch;
            background-image: linear-gradient(120deg, var(--bg-primary-light), var(--bg-primary-dark));
            color: var(--text-primary);
            display: flex; 
            min-height: 100vh;
            overflow-x: hidden; 
        }
       
        .app-wrapper {
            display: flex;
            width: 100%;
            flex-grow: 1;
            position: relative; 
        }

        #app-sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--sidebar-border);
            padding: 1.5rem 0.5rem; 
            position: fixed; 
            top: 0;
            left: 0;
            bottom: 0;
            z-index: 40;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
            box-shadow: var(--sidebar-shadow);
            transform: translateX(calc(-1 * var(--sidebar-width))); 
        }
        #app-sidebar.open {
            transform: translateX(0);
        }
        #app-sidebar-header {
            padding: 0 1rem 1rem 1rem; 
            border-bottom: 1px solid var(--sidebar-border);
            margin-bottom: 1rem;
        }
        #sidebar-title {
            font-size: 1.25rem; 
            font-weight: 700; 
            color: var(--text-accent-strong);
        }
        #sidebar-sentence-list {
            display: flex;
            flex-direction: column;
            gap: 0.1rem; 
        }
        .sidebar-item {
            padding: 0.6rem 1rem; 
            border-radius: 0.375rem; 
            cursor: pointer;
            font-size: 0.875rem; 
            color: var(--sidebar-text);
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px solid var(--sidebar-border); 
        }
        .sidebar-item:last-child {
            border-bottom: none;
        }
        .sidebar-item:hover {
            background-color: var(--sidebar-item-hover-bg);
        }
        .sidebar-item.active {
            background-color: var(--sidebar-item-active-bg);
            color: var(--sidebar-item-active-text);
            font-weight: 600;
            border-left: 4px solid var(--sidebar-item-active-border);
            padding-left: calc(1rem - 4px); 
            border-bottom-color: transparent; 
        }
        #sidebar-toggle-btn {
            background-color: var(--container-bg);
            border: 1px solid var(--input-border);
            padding: 0.5rem;
            border-radius: 0.375rem;
            z-index: 50; 
        }

        .content-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 100vh; 
            margin-left: 0; 
            transition: margin-left 0.3s ease-in-out;
            width: 100%; 
        }
        .content-wrapper.sidebar-open {
            /* margin-left will be applied via JS for larger screens */
        }
         @media (min-width: 769px) { 
            .content-wrapper.sidebar-open {
                 margin-left: var(--sidebar-width);
            }
        }


        .main-container {
            background-color: var(--container-bg);
            box-shadow: var(--container-shadow);
            border-radius: 0.75rem; 
            margin: 1rem auto; 
            padding: 1rem; /* Default padding */
            width: calc(100% - 2rem); /* Ensure padding is accounted for */
            max-width: 48rem; 
            flex-grow: 1; 
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .main-container {
                padding: 1.5rem; /* p-6 */
            }
        }
        @media (min-width: 768px) { /* md breakpoint */
            .main-container {
                padding: 2rem; /* p-8 */
            }
        }


        #input-section textarea { min-height: 100px; border-width: 2px; border-color: var(--input-border); background-color: var(--container-bg); color: var(--text-primary); }
        #input-section textarea::placeholder { color: var(--text-secondary); }
        #input-section textarea:focus { border-color: var(--input-focus-border); box-shadow: 0 0 0 2px var(--input-focus-ring); }
        #learning-section textarea.user-answer-input { min-height: 60px; border-width: 1px; border-color: var(--input-border); background-color: var(--container-bg); color: var(--text-primary); }
        #learning-section textarea.user-answer-input::placeholder { color: var(--text-secondary); }
        #learning-section textarea.user-answer-input:focus { border-color: var(--input-focus-border); box-shadow: 0 0 0 1px var(--input-focus-ring); }

        .message { padding: 0.75rem 1rem; margin-bottom: 1rem; border-radius: 0.375rem; font-weight: 500; transition: opacity 0.3s ease-in-out; }
        .message-error { background-color: var(--message-error-bg); color: var(--message-error-text); border: 1px solid var(--message-error-border); }
        .message-warning { background-color: var(--message-warning-bg); color: var(--message-warning-text); border: 1px solid var(--message-warning-border); }
        .message-success { background-color: var(--message-success-bg); color: var(--message-success-text); border: 1px solid var(--message-success-border); }
        .message-info { background-color: var(--message-info-bg); color: var(--message-info-text); border: 1px solid var(--message-info-border); }


        .btn { font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.375rem; transition-property: background-color, border-color, color, box-shadow, transform; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; font-size: 0.875rem; line-height: 1.25rem; border: 1px solid var(--input-border); box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); cursor: pointer; display: inline-block; text-align: center; color: var(--btn-text-color); }
        .btn:hover { box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .btn:active { box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        .btn:focus { outline: 2px solid transparent; outline-offset: 2px; }
        .btn-primary { background-color: var(--btn-primary-bg); border-color: var(--btn-primary-border); }
        .btn-primary:hover { background-color: var(--btn-primary-hover-bg); }
        .btn-primary:active { background-color: var(--btn-primary-active-bg); }
        .btn-primary:focus { box-shadow: 0 0 0 3px var(--btn-primary-focus-ring); }

        .btn-toggle-original-first { background-color: var(--btn-primary-bg); border-color: var(--btn-primary-border); padding: 0.75rem 1.5rem; font-size: 1rem; line-height: 1.5rem; }
        .btn-toggle-original-first:hover { background-color: var(--btn-primary-hover-bg); }
        .btn-toggle-original-first:active { background-color: var(--btn-primary-active-bg); }
        .btn-toggle-original-first:focus { box-shadow: 0 0 0 3px var(--btn-primary-focus-ring); }

        .btn-toggle-translation-first { background-color: #8b5cf6; border-color: #7c3aed; padding: 0.75rem 1.5rem; font-size: 1rem; line-height: 1.5rem; }
        .btn-toggle-translation-first:hover { background-color: #7c3aed; }
        .btn-toggle-translation-first:active { background-color: #6d28d9; }
        .btn-toggle-translation-first:focus { box-shadow: 0 0 0 3px rgba(192, 132, 252, 0.45); }
        html.dark .btn-toggle-translation-first { background-color: #a78bfa; border-color: #8b5cf6; }
        html.dark .btn-toggle-translation-first:hover { background-color: #8b5cf6; }

        .btn-display-priority-original { background-color: #6366f1; border-color: #4f46e5; padding: 0.625rem 1.25rem; font-size: 0.875rem; }
        .btn-display-priority-original:hover { background-color: #4f46e5; }
        .btn-display-priority-original:active { background-color: #4338ca; }
        .btn-display-priority-original:focus { box-shadow: 0 0 0 3px rgba(165, 180, 252, 0.45); }
        html.dark .btn-display-priority-original { background-color: #818cf8; border-color: #6366f1; }
        html.dark .btn-display-priority-original:hover { background-color: #6366f1; }

        .btn-display-priority-translation { background-color: #f97316; border-color: #ea580c; padding: 0.625rem 1.25rem; font-size: 0.875rem; }
        .btn-display-priority-translation:hover { background-color: #ea580c; }
        .btn-display-priority-translation:active { background-color: #c2410c; }
        .btn-display-priority-translation:focus { box-shadow: 0 0 0 3px rgba(253, 186, 116, 0.45); }
        html.dark .btn-display-priority-translation { background-color: #fb923c; border-color: #f97316; }
        html.dark .btn-display-priority-translation:hover { background-color: #f97316; }

        .btn-secondary { background-color: #64748b; border-color: #475569; color: white; }
        .btn-secondary:hover { background-color: #475569; }
        .btn-secondary:active { background-color: #334155; }
        .btn-secondary:focus { box-shadow: 0 0 0 3px rgba(148, 163, 184, 0.45); }
        html.dark .btn-secondary { background-color: #475569; border-color: #334155; color: #e2e8f0; }
        html.dark .btn-secondary:hover { background-color: #334155; }

        .btn-warning { background-color: #f59e0b; border-color: #d97706; }
        .btn-warning:hover { background-color: #d97706; }
        .btn-warning:active { background-color: #b45309; }
        .btn-warning:focus { box-shadow: 0 0 0 3px rgba(252, 211, 77, 0.45); }
        html.dark .btn-warning { background-color: #facc15; border-color: #eab308; color: #422006;}
        html.dark .btn-warning:hover { background-color: #eab308; }

        .btn-info { background-color: #38bdf8; border-color: #0ea5e9; }
        .btn-info:hover { background-color: #0ea5e9; }
        .btn-info:active { background-color: #0284c7; }
        .btn-info:focus { box-shadow: 0 0 0 3px rgba(125, 211, 252, 0.45); }
        html.dark .btn-info { background-color: #7dd3fc; border-color: #38bdf8; color: #075985;}
        html.dark .btn-info:hover { background-color: #38bdf8; }

        .btn-success { background-color: #22c55e; border-color: #16a34a; }
        .btn-success:hover { background-color: #16a34a; }
        .btn-success:active { background-color: #15803d; }
        .btn-success:focus { box-shadow: 0 0 0 3px rgba(134, 239, 172, 0.45); }
        html.dark .btn-success { background-color: #4ade80; border-color: #22c55e; color: #14532d;}
        html.dark .btn-success:hover { background-color: #22c55e; }

        .btn-danger { background-color: #f43f5e; border-color: #e11d48; }
        .btn-danger:hover { background-color: #e11d48; }
        .btn-danger:active { background-color: #be123c; }
        .btn-danger:focus { box-shadow: 0 0 0 3px rgba(253, 164, 175, 0.45); }
        html.dark .btn-danger { background-color: #fb7185; border-color: #f43f5e; color: #7f1d1d;} /* Dark mode danger text color for better contrast */
        html.dark .btn-danger:hover { background-color: #f43f5e; }

        .btn-small { padding: 0.25rem 0.75rem; font-size: 0.75rem; line-height: 1rem; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none; border-color: var(--input-border); background-color: var(--history-item-bg); color: var(--text-secondary); }

        ::selection { background-color: var(--selection-bg); color: var(--selection-text); }
        ::-moz-selection { background-color: var(--selection-bg); color: var(--selection-text); }

        #history-items-container, #mysets-container { background-color: var(--history-item-bg); border: 1px solid var(--history-item-border); border-radius: 0.375rem; }
        #history-items-container::-webkit-scrollbar, #mysets-container::-webkit-scrollbar { width: 8px; }
        #history-items-container::-webkit-scrollbar-track, #mysets-container::-webkit-scrollbar-track { background: transparent; }
        #history-items-container::-webkit-scrollbar-thumb, #mysets-container::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        #history-items-container::-webkit-scrollbar-thumb:hover, #mysets-container::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
       
        .history-item, .myset-item { background-color: var(--container-bg); border-color: var(--input-border); }
        .history-item:hover, .myset-item:hover { background-color: var(--history-item-hover-bg); }
        html.dark .history-item .text-teal-600, html.dark .myset-item .text-teal-600 { color: var(--text-accent); }
        .myset-item-buttons button { margin-left: 0.5rem;}


        .answer-correct { color: #10b981; } html.dark .answer-correct { color: #34d399; }
        .answer-incorrect { color: #ef4444; } html.dark .answer-incorrect { color: #f87171; }
        .audio-player { width: 100%; margin-top: 0.5rem; }
        html.dark .audio-player { filter: invert(90%) hue-rotate(180deg); }

        #app-menu-bar { background-color: var(--container-bg); color: var(--text-primary); padding: 0.5rem 1rem; border-bottom: 1px solid var(--input-border); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        html.dark #app-menu-bar { box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #app-menu-bar select, #app-menu-bar button:not(#sidebar-toggle-btn) { 
             background-color: var(--bg-primary-light); 
             color: var(--text-primary); border: 1px solid var(--input-border); border-radius: 0.375rem; padding: 0.25rem 0.5rem; 
        }
        #app-menu-bar select:focus, #app-menu-bar button:not(#sidebar-toggle-btn):focus { outline: 2px solid transparent; outline-offset: 2px; border-color: var(--input-focus-border); box-shadow: 0 0 0 2px var(--input-focus-ring); }
        .menu-label { font-size: 0.875rem; font-weight: 500; }
       
        .sentence-pair { background-color: var(--sentence-pair-bg); border: 1px solid var(--sentence-pair-border); padding: 1.25rem; border-radius: 0.5rem; transition: box-shadow 0.3s; }
        .sentence-pair:hover { box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
        html.dark .sentence-pair:hover { box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,0,0,0.15); }
        .original-sentence { color: var(--original-sentence-text); font-size: 1.25rem; font-weight: 600; margin-bottom: 0.5rem; word-break: break-word; }
        .translation-sentence { background-color: var(--translation-sentence-bg); color: var(--translation-sentence-text); border: 1px solid var(--translation-sentence-border); font-size: 1.125rem; padding: 0.75rem; border-radius: 0.375rem; margin-top: 0.5rem; word-break: break-word; }

        /* Removed previous file input specific dark mode styles as they are part of the new structure */
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-0">
    <div class="app-wrapper">
        <aside id="app-sidebar">
            <div id="app-sidebar-header">
                <h2 id="sidebar-title">ナビゲーション</h2>
            </div>
            <div id="sidebar-sentence-list">
                </div>
        </aside>

        <div class="content-wrapper">
            <nav id="app-menu-bar" class="w-full">
                <div class="max-w-3xl mx-auto flex items-center justify-between gap-x-4 py-2 px-2">
                    <button id="sidebar-toggle-btn" aria-label="Toggle sidebar" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
                        </svg>
                    </button>
                   
                    <div class="flex items-center space-x-4 ml-auto"> 
                        <div class="flex items-center space-x-2">
                            <label for="language-select" class="menu-label" id="language-select-label">Language:</label>
                            <select id="language-select" class="text-sm">
                                <option value="ja">日本語</option>
                                <option value="en">English</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-2">
                            <label for="theme-select" class="menu-label" id="theme-select-label">Theme:</label>
                            <select id="theme-select" class="text-sm">
                                <option value="light" id="theme-light-option">Light</option>
                                <option value="dark" id="theme-dark-option">Dark</option>
                                <option value="system" id="theme-system-option">System</option>
                            </select>
                        </div>
                    </div>
                </div>
            </nav>

            <div class="w-full max-w-3xl main-container">
                <header class="mb-4"> 
                    <div class="flex justify-between items-center mb-2"> 
                        <h1 id="app-title" class="text-3xl md:text-4xl font-bold" style="color: var(--text-accent-strong);">多言語学習アプリ</h1>
                    </div>
                </header>

                <div id="input-section" class="space-y-4 mb-6"> 
                    <div id="mode-selection" class="mb-3"> 
                        <h3 id="mode-select-label" class="text-lg font-medium mb-2" style="color: var(--text-primary);">学習モード:</h3>
                        <div class="flex flex-wrap gap-2">
                            <button id="mode-memorization-btn" data-mode="memorization" class="mode-btn btn btn-sm">暗記</button>
                            <button id="mode-test-btn" data-mode="test" class="mode-btn btn btn-sm">確認</button>
                            <button id="mode-audio-btn" data-mode="audio" class="mode-btn btn btn-sm">音声</button>
                        </div>
                    </div>

                    <div id="audio-input-container" class="hidden mb-3">
                        <label for="audio-files-input" id="audio-files-label" class="block text-sm font-medium mb-1" style="color: var(--text-primary);">音声ファイル (学習開始前に選択):</label>
                        <div class="relative border border-gray-300 dark:border-gray-600 bg-white dark:bg-slate-700 rounded-md flex items-center overflow-hidden focus-within:ring-1 focus-within:ring-teal-500 focus-within:border-teal-500 h-10 shadow-sm">
                            <input type="file" id="audio-files-input" multiple
                                   accept=".mp3,audio/mpeg,.m4a,audio/x-m4a,audio/aac,audio/mp4"
                                   class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20"
                                   aria-labelledby="audio-files-label">

                            <label for="audio-files-input" class="flex-shrink-0 h-full flex items-center justify-center cursor-pointer 
                                                                   py-2 px-3 border-r border-gray-300 dark:border-gray-500
                                                                   text-sm font-semibold 
                                                                   bg-teal-50 text-teal-700 hover:bg-teal-100
                                                                   dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500 transition-colors duration-150">
                                <span id="audio-select-button-text">ファイル選択</span>
                            </label>

                            <span id="audio-file-names-display"
                                  class="text-xs px-3 flex-grow truncate self-center leading-tight" 
                                  style="color: var(--text-secondary);">
                                ファイル未選択
                            </span>
                        </div>
                    </div>

                    <div class="flex flex-col sm:flex-row gap-2 mb-3"> 
                        <input type="file" id="csv-file-input" accept=".csv" class="hidden">
                        <button id="import-csv-btn" class="btn btn-success w-full sm:w-auto text-base">CSVから入力</button>
                        <button id="export-csv-btn" class="btn btn-success w-full sm:w-auto text-base">CSVへ出力</button>
                    </div>

                    <div class="mt-2 mb-4 space-y-2 border-t border-b py-3" style="border-color: var(--input-border);"> 
                        <div class="flex flex-col sm:flex-row gap-2 items-center justify-between">
                            <h3 id="history-section-title" class="text-lg font-medium self-start sm:self-center" style="color: var(--text-primary);">入力履歴</h3>
                            <div class="flex gap-2 self-end sm:self-center">
                                <button id="toggle-history-btn" class="btn btn-info btn-small">履歴を表示</button>
                                <button id="clear-history-btn" class="btn btn-danger btn-small" disabled>履歴をクリア</button>
                            </div>
                        </div>
                        <div id="history-items-container" class="hidden max-h-60 overflow-y-auto space-y-2 p-2">
                            <p id="no-history-message" class="text-center py-2" style="color: var(--text-secondary);">履歴はありません。</p>
                        </div>
                    </div>
                     <div id="mysets-section" class="mt-2 mb-4 space-y-2 border-t border-b py-3" style="border-color: var(--input-border);">
                        <div class="flex flex-col sm:flex-row gap-2 items-center justify-between">
                            <h3 id="mysets-section-title" class="text-lg font-medium self-start sm:self-center" style="color: var(--text-primary);">マイセット</h3>
                            <div class="flex gap-2 self-end sm:self-center">
                                <button id="toggle-mysets-btn" class="btn btn-info btn-small">マイセットを表示</button>
                            </div>
                        </div>
                        <div id="mysets-container" class="hidden max-h-60 overflow-y-auto space-y-2 p-2">
                            <p id="no-mysets-message" class="text-center py-2" style="color: var(--text-secondary);">マイセットはありません。</p>
                        </div>
                    </div>


                    <div>
                        <label for="original-text" id="original-text-label" class="block text-lg font-medium mb-2" style="color: var(--text-primary);">原文 (中国語・英語・日本語):</label>
                        <textarea id="original-text" rows="4" class="w-full p-3 rounded-md shadow-sm resize-y"
                                  placeholder="ここに原文の長文テキストを入力してください。文の区切りは「.」「?」「!」「。」「？」「！」です。"></textarea>
                    </div>
                    <div>
                        <label for="translation-text" id="translation-text-label" class="block text-lg font-medium mb-2" style="color: var(--text-primary);">訳文 (中国語・英語・日本語):</label>
                        <textarea id="translation-text" rows="4" class="w-full p-3 rounded-md shadow-sm resize-y"
                                  placeholder="ここに訳文の長文テキストを入力してください。文の区切りは「.」「?」「!」「。」「？」「！」です。"></textarea>
                    </div>
                    <div class="flex items-center space-x-4">
                        <span id="display-priority-label" class="text-sm" style="color: var(--text-secondary);">初期表示 (暗記モード):</span>
                        <button id="toggle-display-priority-btn" class="btn">原文を隠す</button>
                    </div>
                     <button id="save-myset-btn" class="btn btn-success w-full sm:w-auto text-base">マイセットとして保存</button>

                    <div id="message-area" class="mt-3" aria-live="polite"></div> 
                    <div class="flex flex-col sm:flex-row gap-4">
                        <button id="start-learning-btn" class="btn btn-primary w-full sm:w-auto text-base">学習開始</button>
                        <button id="reset-all-btn" class="btn btn-secondary w-full sm:w-auto text-base">リセット</button>
                    </div>
                     <button id="clear-app-data-btn" class="btn btn-danger w-full sm:w-auto text-base mt-4">アプリデータをクリア</button>
                </div>

                <main id="learning-section" class="hidden">
                    <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
                        <button id="undo-merge-btn" class="btn btn-danger" disabled>元に戻す</button>
                        <button id="shuffle-pairs-btn" class="btn btn-info">ペアをシャッフル</button>
                        <button id="filter-incorrect-btn" class="btn btn-warning" disabled>間違えたペアを絞り込む</button>
                        <button id="toggle-all-translations-btn" class="btn btn-info hidden">訳文を一括表示</button>
                        <button id="back-to-input-btn" class="btn btn-secondary">入力に戻る</button>
                    </div>
                    <div id="sentence-container" class="space-y-6">
                        </div>
                </main>

                <footer class="mt-8 text-center text-sm" style="color: var(--text-secondary);"> 
                    <p id="footer-text">&copy; 2025 siomiso</p>
                </footer>
            </div>
        </div>
    </div>

    <script defer>
    // --- Global Variables & State Management ---
    let currentPairedSentences = [];
    let undoHistory = [];
    let redoHistory = []; 
    const MAX_UNDO_HISTORY = 10;

    let currentSelectedLang = 'ja'; 
    let displayPriority = 'originalFirst'; // 'originalFirst' or 'translationFirst'
    let textInputHistory = [];
    const MAX_TEXT_HISTORY_ITEMS = 20;
    const TEXT_HISTORY_STORAGE_KEY = 'multiLangAppHistory_v2';
    const MY_SETS_STORAGE_KEY = 'multiLangAppMySets_v1'; 
    const THEME_STORAGE_KEY = 'multiLangAppTheme_v1';
    const LANGUAGE_STORAGE_KEY = 'multiLangAppLanguage_v1';

    let currentMode = 'memorization'; // 'memorization', 'test', 'audio'
    let loadedAudioFiles = []; // Stores { file: File, url: string }
    let audioObjectUrls = []; // To keep track of Object URLs for revocation

    let allTranslationsManuallyToggled = false; // For memorization mode's "toggle all"

    let incorrectlyAnsweredPairs = new Set(); // Stores IDs of incorrectly answered pairs
    let isFilteringIncorrect = false; // Flag to indicate if filtering is active
    let lastOriginalTextForIncorrectTracking = ""; // To reset incorrect set if input changes
    let lastTranslationTextForIncorrectTracking = ""; // To reset incorrect set if input changes

    let activeSidebarItemId = null; 
    let mySets = []; 


    // --- i18n (Internationalization) Data ---
    const i18nData = {
        ja: {
            appTitle: "多言語学習アプリ",
            originalTextLabel: "原文 (中国語・英語・日本語):",
            translationTextLabel: "訳文 (中国語・英語・日本語):",
            originalPlaceholder: "ここに原文の長文テキストを入力してください。文の区切りは「.」「?」「!」「。」「？」「！」です。",
            translationPlaceholder: "ここに訳文の長文テキストを入力してください。文の区切りは「.」「?」「!」「。」「？」「！」です。",
            startLearning: "学習開始",
            reset: "リセット",
            importCsv: "CSVから入力",
            exportCsv: "CSVへ出力",
            undoMerge: "元に戻す",
            showTranslation: "訳文を表示",
            hideTranslation: "訳文を隠す",
            showOriginal: "原文を表示",
            hideOriginal: "原文を隠す",
            mergeWithPreviousOriginal: "前の原文と結合",
            mergeWithPreviousTranslation: "前の訳文と結合",
            mergePairWithPrevious: "ペアごと前と結合",
            backToInput: "入力に戻る",
            displayPriorityLabel: "初期表示:", 
            toggleDisplayPriorityOriginalFirst: "訳文を隠す (原文優先)",
            toggleDisplayPriorityTranslationFirst: "原文を隠す (訳文優先)",
            errorBothTextsRequired: "原文と訳文の両方を入力してください。",
            errorNoValidSentences: "有効な文が見つかりませんでした。区切り文字を確認してください。",
            warningSentenceCountMismatch: (originalCount, translationCount, pairCount) => `原文 ${originalCount}件、訳文 ${translationCount}件でした。短い方の ${pairCount}件でペアを作成します。`,
            successPairsCreated: (pairCount) => `${pairCount}件のペアを作成しました。`,
            successMerged: "文を結合し、リストを更新しました。",
            successPairMerged: "ペアを結合し、リストを更新しました。",
            successReset: "入力をリセットしました。",
            successUndo: "操作を元に戻しました。",
            errorNoUndoState: "元に戻せる操作がありません。",
            noPairsToDisplay: "表示するペアがありません。",
            successCsvImported: "CSVからテキストを読み込みました。「学習開始」ボタンを押してください。",
            errorCsvFormat: "CSVファイルの形式が正しくありません。A列に原文、B列に訳文が入力されていることを確認してください。",
            errorNoPairsToExport: "エクスポートするペアがありません。",
            delimiterRegex: /(?<=[.?!。？！])\s*/g,
            historySectionTitle: "入力履歴",
            showHistory: "履歴を表示",
            hideHistory: "履歴を隠す",
            clearHistory: "履歴をクリア",
            manualInputLabel: "手入力",
            noHistory: "履歴はありません。",
            confirmClearHistory: "本当に入力履歴をすべて削除しますか？この操作は元に戻せません。",
            historyCleared: "入力履歴をクリアしました。",
            loadedFromHistory: "履歴からテキストを読み込みました。",
            historyItemSourceLabel: "ソース: ",
            modeSelectLabel: "学習モード:",
            memorizationMode: "暗記",
            testMode: "確認",
            audioMode: "音声",
            audioFilesLabel: "音声ファイル (学習開始前に選択):",
            audioSelectButtonText: "ファイル選択", 
            shufflePairs: "ペアをシャッフル",
            successShuffled: "ペアの順番をシャッフルしました。",
            enterYourAnswerPlaceholder: "ここに訳文を入力してください",
            enterYourOriginalPlaceholder: "ここに原文を入力してください", 
            checkAnswer: "判定",
            correctAnswerSymbol: "○",
            incorrectAnswerSymbol: "×",
            answerCorrect: "正解です！",
            answerIncorrect: "不正解です。",
            markCorrectManual: "正解にする",
            markIncorrectManual: "不正解にする",
            noAudioForThisPair: "このペアの音声はありません。",
            errorAudioFileAssignment: "音声ファイルの割り当てに問題が発生しました。ペアの数とファイル数が一致しないか、ファイルが選択されていません。",
            warningNotAllPairsHaveAudio: (assignedCount, totalPairs) => `音声ファイル ${assignedCount}件を ${totalPairs}件のペアに割り当てました。一部のペアには音声がない可能性があります。`,
            errorNoAudioFilesSelectedForAudioMode: "音声モードが選択されていますが、音声ファイルが読み込まれていません。「入力に戻る」からファイルを選択してください。",
            showOriginalAudio: "原文表示", 
            hideOriginalAudio: "原文非表示", 
            showTranslationAudio: "訳文表示", 
            hideTranslationAudio: "訳文非表示", 
            showAllTranslations: "訳文を一括表示",
            hideAllTranslations: "訳文を一括非表示",
            filterIncorrect: "間違えたペアを絞り込む", 
            showAllPairs: "すべてのペアを表示", 
            noIncorrectPairsToFilter: "絞り込む間違えたペアはありません。", 
            sidebarTitle: "ナビゲーション",
            footerText: "&copy; 2025 siomiso", 
            languageSelectLabel: "言語:",
            themeSelectLabel: "テーマ:",
            themeLightOption: "ライト",
            themeDarkOption: "ダーク",
            themeSystemOption: "システム",
            csvExportNotSupported: "このブラウザではCSVエクスポートが完全にはサポートされていない可能性があります。",
            audioFilesSelected: (count) => `${count}件の音声ファイルを選択しました。`,
            mySetsSectionTitle: "マイセット",
            showMySets: "マイセットを表示",
            hideMySets: "マイセットを隠す",
            saveMySet: "マイセットとして保存",
            noMySets: "マイセットはありません。",
            enterMySetName: "マイセットの名前を入力してください:",
            mySetSaved: (name) => `「${name}」をマイセットに保存しました。`,
            mySetLoaded: (name) => `マイセット「${name}」を読み込みました。`,
            confirmDeleteMySet: (name) => `マイセット「${name}」を本当に削除しますか？`,
            mySetDeleted: (name) => `マイセット「${name}」を削除しました。`,
            errorSavingMySetNoName: "セット名が入力されていません。",
            errorSavingMySetEmpty: "原文または訳文が空のため、マイセットとして保存できません。",
            unnamedMySet: "(無名のセット)", 
            clearAppData: "アプリデータをクリア",
            confirmClearAppData: "アプリの全データ（履歴、マイセット、設定）をクリアしますか？この操作は元に戻せません。",
            appDataCleared: "アプリデータをクリアしました。ページをリロードします。",
            noAudioFileSelectedDefaultText: "ファイル未選択"
        },
        en: {
            appTitle: "Multilingual Learning App",
            originalTextLabel: "Original Text (Chinese/English/Japanese):",
            translationTextLabel: "Translated Text (Chinese/English/Japanese):",
            originalPlaceholder: "Enter the original long text here. Sentences are delimited by '.', '?', '!', '。', '？', '！'.",
            translationPlaceholder: "Enter the translated long text here. Sentences are delimited by '.', '?', '!', '。', '？', '！'.",
            startLearning: "Start Learning",
            reset: "Reset",
            importCsv: "Import from CSV",
            exportCsv: "Export to CSV",
            undoMerge: "Undo Merge",
            showTranslation: "Show Translation",
            hideTranslation: "Hide Translation",
            showOriginal: "Show Original",
            hideOriginal: "Hide Original",
            mergeWithPreviousOriginal: "Merge with Previous Original",
            mergeWithPreviousTranslation: "Merge with Previous Translation",
            mergePairWithPrevious: "Merge Pair with Previous",
            backToInput: "Back to Input",
            displayPriorityLabel: "Initial Display:", 
            toggleDisplayPriorityOriginalFirst: "Hide Translation (Original First)",
            toggleDisplayPriorityTranslationFirst: "Hide Original (Translation First)",
            errorBothTextsRequired: "Please enter both original and translated texts.",
            errorNoValidSentences: "No valid sentences found. Please check the delimiters.",
            warningSentenceCountMismatch: (originalCount, translationCount, pairCount) => `Found ${originalCount} original sentences and ${translationCount} translated sentences. Creating ${pairCount} pairs based on the shorter count.`,
            successPairsCreated: (pairCount) => `Successfully created ${pairCount} pairs.`,
            successMerged: "Sentences merged and list updated.",
            successPairMerged: "Pair merged and list updated.",
            successReset: "Inputs have been reset.",
            successUndo: "Last action undone.",
            errorNoUndoState: "No action to undo.",
            noPairsToDisplay: "No pairs to display.",
            successCsvImported: "Text imported from CSV. Press 'Start Learning'.",
            errorCsvFormat: "Incorrect CSV file format. Ensure column A has original text and column B has translations.",
            errorNoPairsToExport: "No pairs to export.",
            delimiterRegex: /(?<=[.?!])\s*/g, 
            historySectionTitle: "Input History",
            showHistory: "Show History",
            hideHistory: "Hide History",
            clearHistory: "Clear History",
            manualInputLabel: "Manual Input",
            noHistory: "No history yet.",
            confirmClearHistory: "Are you sure you want to delete all input history? This action cannot be undone.",
            historyCleared: "Input history cleared.",
            loadedFromHistory: "Loaded text from history.",
            historyItemSourceLabel: "Source: ",
            modeSelectLabel: "Learning Mode:",
            memorizationMode: "Memorization",
            testMode: "Test",
            audioMode: "Audio",
            audioFilesLabel: "Audio Files (Select before starting):",
            audioSelectButtonText: "Choose File(s)", 
            shufflePairs: "Shuffle Pairs",
            successShuffled: "Pair order has been shuffled.",
            enterYourAnswerPlaceholder: "Enter your translation here",
            enterYourOriginalPlaceholder: "Enter original text here", 
            checkAnswer: "Check",
            correctAnswerSymbol: "✓",
            incorrectAnswerSymbol: "✗",
            answerCorrect: "Correct!",
            answerIncorrect: "Incorrect.",
            markCorrectManual: "Mark Correct",
            markIncorrectManual: "Mark Incorrect",
            noAudioForThisPair: "No audio for this pair.",
            errorAudioFileAssignment: "Problem assigning audio files. Number of files might not match pairs, or no files selected.",
            warningNotAllPairsHaveAudio: (assignedCount, totalPairs) => `Assigned ${assignedCount} audio files to ${totalPairs} pairs. Some pairs may not have audio.`,
            errorNoAudioFilesSelectedForAudioMode: "Audio mode is selected, but no audio files are loaded. Please go 'Back to Input' to select files.",
            showOriginalAudio: "Show Original", 
            hideOriginalAudio: "Hide Original", 
            showTranslationAudio: "Show Translation", 
            hideTranslationAudio: "Hide Translation", 
            showAllTranslations: "Show All Translations",
            hideAllTranslations: "Hide All Translations",
            filterIncorrect: "Filter Incorrect Pairs", 
            showAllPairs: "Show All Pairs", 
            noIncorrectPairsToFilter: "No incorrect pairs to filter.", 
            sidebarTitle: "Navigation",
            footerText: "&copy; 2025 siomiso", 
            languageSelectLabel: "Language:",
            themeSelectLabel: "Theme:",
            themeLightOption: "Light",
            themeDarkOption: "Dark",
            themeSystemOption: "System",
            csvExportNotSupported: "CSV export might not be fully supported on this browser.",
            audioFilesSelected: (count) => `Selected ${count} audio file(s).`,
            mySetsSectionTitle: "My Sets",
            showMySets: "Show My Sets",
            hideMySets: "Hide My Sets",
            saveMySet: "Save as My Set",
            noMySets: "No sets saved yet.",
            enterMySetName: "Enter a name for this set:",
            mySetSaved: (name) => `Set "${name}" saved.`,
            mySetLoaded: (name) => `Loaded set "${name}".`,
            confirmDeleteMySet: (name) => `Are you sure you want to delete the set "${name}"?`,
            mySetDeleted: (name) => `Set "${name}" deleted.`,
            errorSavingMySetNoName: "Set name cannot be empty.",
            errorSavingMySetEmpty: "Cannot save an empty set. Please enter original or translation text.",
            unnamedMySet: "(Unnamed Set)",
            clearAppData: "Clear App Data",
            confirmClearAppData: "Are you sure you want to clear all app data (history, my sets, settings)? This action cannot be undone.",
            appDataCleared: "App data cleared. Reloading page.",
            noAudioFileSelectedDefaultText: "No file selected"
        }
    };
    let t = i18nData[currentSelectedLang]; 

    // --- DOM Element Retrieval ---
    const originalTextInput = document.getElementById('original-text');
    const translationTextInput = document.getElementById('translation-text');
    const startLearningBtn = document.getElementById('start-learning-btn');
    const resetAllBtn = document.getElementById('reset-all-btn');
    const sentenceContainer = document.getElementById('sentence-container');
    const inputSection = document.getElementById('input-section');
    const learningSection = document.getElementById('learning-section');
    const messageArea = document.getElementById('message-area');
    const backToInputBtn = document.getElementById('back-to-input-btn');
    const toggleDisplayPriorityBtn = document.getElementById('toggle-display-priority-btn');
    const importCsvBtn = document.getElementById('import-csv-btn');
    const exportCsvBtn = document.getElementById('export-csv-btn');
    const csvFileInput = document.getElementById('csv-file-input');
    const undoMergeBtn = document.getElementById('undo-merge-btn');
    const toggleHistoryBtn = document.getElementById('toggle-history-btn');
    const clearHistoryBtn = document.getElementById('clear-history-btn');
    const historyItemsContainer = document.getElementById('history-items-container');
    const noHistoryMessage = document.getElementById('no-history-message');
    const modeMemorizationBtn = document.getElementById('mode-memorization-btn');
    const modeTestBtn = document.getElementById('mode-test-btn');
    const modeAudioBtn = document.getElementById('mode-audio-btn');
    const modeButtons = [modeMemorizationBtn, modeTestBtn, modeAudioBtn];
    const audioInputContainer = document.getElementById('audio-input-container');
    const audioFilesInput = document.getElementById('audio-files-input');
    const audioFileNamesDisplay = document.getElementById('audio-file-names-display');
    const shufflePairsBtn = document.getElementById('shuffle-pairs-btn');
    const toggleAllTranslationsBtn = document.getElementById('toggle-all-translations-btn');
    const filterIncorrectBtn = document.getElementById('filter-incorrect-btn'); 
    const languageSelect = document.getElementById('language-select');
    const themeSelect = document.getElementById('theme-select');
    const appSidebar = document.getElementById('app-sidebar');
    const sidebarSentenceList = document.getElementById('sidebar-sentence-list');
    const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
    const contentWrapper = document.querySelector('.content-wrapper');
    const saveMySetBtn = document.getElementById('save-myset-btn');
    const mysetsContainer = document.getElementById('mysets-container');
    const noMySetsMessage = document.getElementById('no-mysets-message');
    const toggleMySetsBtn = document.getElementById('toggle-mysets-btn');
    const clearAppDataBtn = document.getElementById('clear-app-data-btn');

    // --- Theme Management ---
    function applyTheme(theme) {
        if (theme === 'dark') {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        const themeColorMeta = document.querySelector('meta[name="theme-color"]');
        if (themeColorMeta) {
            themeColorMeta.content = theme === 'dark' ? '#0f172a' : '#14b8a6';
        }
    }

    function getSystemPreference() {
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    function loadAndApplyTheme() {
        const savedTheme = localStorage.getItem(THEME_STORAGE_KEY) || 'system';
        themeSelect.value = savedTheme;
        if (savedTheme === 'system') {
            applyTheme(getSystemPreference());
        } else {
            applyTheme(savedTheme);
        }
    }

    themeSelect.addEventListener('change', (e) => {
        const selectedTheme = e.target.value;
        localStorage.setItem(THEME_STORAGE_KEY, selectedTheme);
        if (selectedTheme === 'system') {
            applyTheme(getSystemPreference());
        } else {
            applyTheme(selectedTheme);
        }
    });

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        if (themeSelect.value === 'system') {
            applyTheme(e.matches ? 'dark' : 'light');
        }
    });

    // --- Language Management ---
    function setLanguage(lang) {
        if (i18nData[lang]) {
            currentSelectedLang = lang;
            t = i18nData[currentSelectedLang];
            localStorage.setItem(LANGUAGE_STORAGE_KEY, lang);
            document.documentElement.lang = lang;
            updateUIText();
            if (!learningSection.classList.contains('hidden') && currentPairedSentences.length > 0) {
                renderSentences(); 
            }
            renderTextInputHistoryList();
            renderMySetList(); 
            updateFilterIncorrectButtonState(); 
        }
    }

    languageSelect.addEventListener('change', (e) => {
        setLanguage(e.target.value);
    });

    function loadAndApplyLanguage() {
        const savedLang = localStorage.getItem(LANGUAGE_STORAGE_KEY) || 'ja';
        languageSelect.value = savedLang;
        setLanguage(savedLang);
    }


    // --- Undo/Redo Helper Functions ---
    function saveStateForUndo() {
        const stateToSave = {
            pairs: JSON.parse(JSON.stringify(currentPairedSentences)), 
            incorrectIds: Array.from(incorrectlyAnsweredPairs) 
        };
        undoHistory.push(stateToSave);
        if (undoHistory.length > MAX_UNDO_HISTORY) {
            undoHistory.shift();
        }
        redoHistory = []; // Clear redo history on new action
        updateUndoRedoButtonStates();
    }

    function updateUndoRedoButtonStates() {
        undoMergeBtn.disabled = undoHistory.length === 0;
        // Redo button can be added here if needed
    }

    function clearUndoRedoHistory() {
        undoHistory = [];
        redoHistory = [];
        updateUndoRedoButtonStates();
    }

    // --- UI Update Functions ---
    function updateUIText() {
        document.title = t.appTitle;
        document.getElementById('app-title').textContent = t.appTitle;
        document.getElementById('original-text-label').textContent = t.originalTextLabel;
        document.getElementById('translation-text-label').textContent = t.translationTextLabel;
        originalTextInput.placeholder = t.originalPlaceholder;
        translationTextInput.placeholder = t.translationPlaceholder;
        startLearningBtn.textContent = t.startLearning;
        resetAllBtn.textContent = t.reset;
        importCsvBtn.textContent = t.importCsv;
        exportCsvBtn.textContent = t.exportCsv;
        undoMergeBtn.textContent = t.undoMerge;
        backToInputBtn.textContent = t.backToInput;
        document.getElementById('display-priority-label').textContent = t.displayPriorityLabel;

        // Update display priority button text and style
        toggleDisplayPriorityBtn.textContent = displayPriority === 'originalFirst' ? t.toggleDisplayPriorityOriginalFirst : t.toggleDisplayPriorityTranslationFirst;
        toggleDisplayPriorityBtn.classList.remove('btn-display-priority-original', 'btn-display-priority-translation', 'btn-toggle-original-first', 'btn-toggle-translation-first');
        if (displayPriority === 'originalFirst') {
             toggleDisplayPriorityBtn.classList.add(currentMode === 'memorization' ? 'btn-toggle-original-first' : 'btn-display-priority-original');
        } else {
             toggleDisplayPriorityBtn.classList.add(currentMode === 'memorization' ? 'btn-toggle-translation-first' : 'btn-display-priority-translation');
        }


        document.getElementById('history-section-title').textContent = t.historySectionTitle;
        clearHistoryBtn.textContent = t.clearHistory;
        noHistoryMessage.textContent = t.noHistory;
        updateToggleHistoryButtonText();

        document.getElementById('mysets-section-title').textContent = t.mySetsSectionTitle;
        noMySetsMessage.textContent = t.noMySets;
        updateToggleMySetsButtonText();
        saveMySetBtn.textContent = t.saveMySet;


        document.getElementById('mode-select-label').textContent = t.modeSelectLabel;
        modeMemorizationBtn.textContent = t.memorizationMode;
        modeTestBtn.textContent = t.testMode;
        modeAudioBtn.textContent = t.audioMode;
        document.getElementById('audio-files-label').textContent = t.audioFilesLabel;
       
        // Update custom audio button text if it exists
        const audioSelectBtnTextEl = document.getElementById('audio-select-button-text');
        if (audioSelectBtnTextEl) {
            audioSelectBtnTextEl.textContent = t.audioSelectButtonText;
        }

        if (audioFileNamesDisplay) { 
            if (loadedAudioFiles.length > 0) {
                const messageKey = 'audioFilesSelected';
                audioFileNamesDisplay.textContent = typeof t[messageKey] === 'function'
                    ? t[messageKey](loadedAudioFiles.length)
                    : `${loadedAudioFiles.length} ${currentSelectedLang === 'ja' ? '件の音声ファイルを選択しました' : 'audio file(s) selected'}`;
            } else {
                audioFileNamesDisplay.textContent = t.noAudioFileSelectedDefaultText || (currentSelectedLang === 'ja' ? 'ファイル未選択' : 'No file selected');
            }
        }
        shufflePairsBtn.textContent = t.shufflePairs;
        document.getElementById('sidebar-title').textContent = t.sidebarTitle;
        document.getElementById('footer-text').innerHTML = t.footerText; 
        clearAppDataBtn.textContent = t.clearAppData;


        document.getElementById('language-select-label').textContent = t.languageSelectLabel;
        document.getElementById('theme-select-label').textContent = t.themeSelectLabel;
        document.getElementById('theme-light-option').textContent = t.themeLightOption;
        document.getElementById('theme-dark-option').textContent = t.themeDarkOption;
        document.getElementById('theme-system-option').textContent = t.themeSystemOption;

        if (toggleAllTranslationsBtn && !toggleAllTranslationsBtn.classList.contains('hidden')) {
             toggleAllTranslationsBtn.textContent = allTranslationsManuallyToggled ? t.hideAllTranslations : t.showAllTranslations;
        }
        updateFilterIncorrectButtonState(); 
    }

    function updateToggleHistoryButtonText() {
        toggleHistoryBtn.textContent = historyItemsContainer.classList.contains('hidden') ? t.showHistory : t.hideHistory;
    }
     function updateToggleMySetsButtonText() {
        const mysetsContainerEl = document.getElementById('mysets-container'); 
        if (mysetsContainerEl) { 
            toggleMySetsBtn.textContent = mysetsContainerEl.classList.contains('hidden') ? t.showMySets : t.hideMySets;
        }
    }


    function updateModeSelectionUI() {
        modeButtons.forEach(btn => {
            if (btn.dataset.mode === currentMode) {
                btn.classList.remove('btn-secondary'); 
                btn.classList.add('btn-primary');
            } else {
                btn.classList.remove('btn-primary'); 
                btn.classList.add('btn-secondary');
            }
        });
        audioInputContainer.classList.toggle('hidden', currentMode !== 'audio');
        toggleAllTranslationsBtn.classList.toggle('hidden', currentMode !== 'memorization' || currentPairedSentences.length === 0);
        
        // Update display priority button style based on mode
        updateUIText(); // Recalculates button style based on currentMode and displayPriority

        if (!learningSection.classList.contains('hidden') && currentPairedSentences.length > 0) {
            renderSentences(); 
        }
        updateFilterIncorrectButtonState(); 
        updateSidebarVisibility(); 
    }

    // --- Message Display Function ---
    function showMessage(textOrKey, type = 'error', isKey = false, duration = 3000) {
        messageArea.innerHTML = ''; 
        const messageDiv = document.createElement('div');
        let messageText = textOrKey;

        if (isKey) {
            const translation = t[textOrKey];
            if (typeof translation === 'function') {
                // If the i18n value is a function, call it (e.g., for dynamic messages)
                // This part needs arguments if the function expects them.
                // For now, assuming simple key or direct text.
                messageText = translation() || textOrKey; 
            } else {
                messageText = translation || textOrKey; 
            }
        }
       
        messageDiv.textContent = messageText; 
        messageDiv.className = `message message-${type}`; 
        messageArea.appendChild(messageDiv);

        if (type === 'success' || type === 'warning' || type === 'info') { 
            setTimeout(() => {
                if (messageArea.contains(messageDiv)) { 
                    messageArea.removeChild(messageDiv);
                }
            }, duration);
        }
    }


    // --- Text Splitting Function ---
    function splitTextIntoSentences(text) {
        if (!text || !text.trim()) return [];
        // Use the delimiter regex from the currently selected language's i18n data
        const delimiterRegex = i18nData[currentSelectedLang].delimiterRegex || i18nData.ja.delimiterRegex;
        return text.split(delimiterRegex)
                   .map(s => s.trim())
                   .filter(s => s.length > 0);
    }

    // --- Audio File Handling ---
    function revokePreviousAudioUrls() {
        audioObjectUrls.forEach(url => URL.revokeObjectURL(url));
        audioObjectUrls = [];
    }

    // audioFilesInput is the hidden input. Event listener remains on it.
    audioFilesInput.addEventListener('change', (event) => {
        revokePreviousAudioUrls(); 
        const files = Array.from(event.target.files)
            .sort((a, b) =>
                a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' })
            ); // Sort files by name numerically
        loadedAudioFiles = files.map(file => {
            const url = URL.createObjectURL(file);
            audioObjectUrls.push(url); 
            return { file, url }; 
        });
       
        if (audioFileNamesDisplay) { // Ensure the display span exists
            if (loadedAudioFiles.length > 0) {
                const messageKey = 'audioFilesSelected';
                const messageText = typeof t[messageKey] === 'function' 
                    ? t[messageKey](loadedAudioFiles.length) 
                    : `${loadedAudioFiles.length}件の音声ファイルを選択しました。`; 
                audioFileNamesDisplay.textContent = messageText;
            } else {
                audioFileNamesDisplay.textContent = t['noAudioFileSelectedDefaultText'] || 'ファイル未選択'; 
            }
        }
        event.target.value = null; // Reset file input to allow re-selection of same files
    });
   
    // --- Text Input History Functions ---
    function loadTextInputHistoryFromStorage() {
        const storedHistory = localStorage.getItem(TEXT_HISTORY_STORAGE_KEY);
        if (storedHistory) {
            try {
                textInputHistory = JSON.parse(storedHistory);
            } catch (e) {
                console.error("Error parsing text input history from localStorage:", e);
                textInputHistory = []; 
            }
        }
    }

    function saveTextInputHistoryToStorage() {
        localStorage.setItem(TEXT_HISTORY_STORAGE_KEY, JSON.stringify(textInputHistory));
    }

    function addEntryToTextInputHistory(original, translation, sourceFilename) {
        const newSource = sourceFilename || t.manualInputLabel; 
       
        // Avoid adding exact duplicates if they are the most recent entry
        if (textInputHistory.length > 0) {
            const lastEntry = textInputHistory[0];
            if (lastEntry.original === original &&
                lastEntry.translation === translation &&
                lastEntry.source === newSource) {
                textInputHistory.shift(); // Remove the last entry to re-add it at the top (updates timestamp)
            }
        }
        const newEntry = {
            id: `hist-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`, 
            original: original,
            translation: translation,
            source: newSource, 
            timestamp: new Date().toISOString()
        };
        textInputHistory.unshift(newEntry); // Add to the beginning
        if (textInputHistory.length > MAX_TEXT_HISTORY_ITEMS) {
            textInputHistory.pop(); // Remove the oldest if exceeds max
        }
        saveTextInputHistoryToStorage();
        renderTextInputHistoryList();
    }

    function renderTextInputHistoryList() {
        // Clear only dynamic items, keep the "no history" message template
        const dynamicItems = historyItemsContainer.querySelectorAll('div[role="button"]');
        dynamicItems.forEach(item => item.remove());

        if (textInputHistory.length === 0) {
            noHistoryMessage.style.display = 'block';
            noHistoryMessage.textContent = t.noHistory; 
            clearHistoryBtn.disabled = true;
            return;
        }
        noHistoryMessage.style.display = 'none';
        clearHistoryBtn.disabled = false;

        const fragment = document.createDocumentFragment();
        textInputHistory.forEach(entry => {
            const historyEntryDiv = document.createElement('div');
            historyEntryDiv.className = 'history-item p-3 border rounded-md cursor-pointer transition-colors focus:outline-none focus:ring-2 focus:ring-opacity-75';
            historyEntryDiv.setAttribute('role', 'button');
            historyEntryDiv.tabIndex = 0; 
            historyEntryDiv.dataset.historyId = entry.id;

            // Ensure source is translated if it's the "manual input" label
            const sourceDisplay = entry.source === i18nData.ja.manualInputLabel || entry.source === i18nData.en.manualInputLabel 
                ? t.manualInputLabel 
                : `${t.historyItemSourceLabel}${entry.source}`;

            const snippet = entry.original.substring(0, 70) + (entry.original.length > 70 ? '...' : '');
            const localeForDate = currentSelectedLang === 'ja' ? 'ja-JP' : 'en-US'; 

            historyEntryDiv.innerHTML = `
                <p class="text-xs" style="color: var(--text-secondary);">${new Date(entry.timestamp).toLocaleString(localeForDate)}</p>
                <p class="font-medium text-sm" style="color: var(--text-accent-strong);">${sourceDisplay}</p>
                <p class="text-sm break-all" style="color: var(--text-primary);" title="${entry.original.substring(0,200)}...">${snippet}</p>
            `;

            historyEntryDiv.addEventListener('click', () => loadTextInputHistoryEntry(entry.id));
            historyEntryDiv.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') { 
                    e.preventDefault(); 
                    loadTextInputHistoryEntry(entry.id);
                }
            });
            fragment.appendChild(historyEntryDiv);
        });
        historyItemsContainer.appendChild(fragment); 
    }

    function loadTextInputHistoryEntry(entryId) {
        const entry = textInputHistory.find(item => item.id === entryId);
        if (entry) {
            originalTextInput.value = entry.original;
            translationTextInput.value = entry.translation;
           
            // Reset incorrect tracking when loading from history
            lastOriginalTextForIncorrectTracking = entry.original; 
            lastTranslationTextForIncorrectTracking = entry.translation; 
            incorrectlyAnsweredPairs.clear(); 
            isFilteringIncorrect = false;

            showMessage(t.loadedFromHistory, "success", true); 
           
            // Clear learning state as new text is loaded
            currentPairedSentences = []; 
            clearUndoRedoHistory();
            sentenceContainer.innerHTML = '';
            updateUndoRedoButtonStates();
            updateFilterIncorrectButtonState();


            // Switch back to input view if in learning view
            if (!learningSection.classList.contains('hidden')) {
                learningSection.classList.add('hidden');
                inputSection.classList.remove('hidden');
                updateSidebarVisibility();
            }
            originalTextInput.focus();
        }
    }
   
    // --- My Sets Feature ---
    function loadMySetsFromStorage() {
        const storedMySets = localStorage.getItem(MY_SETS_STORAGE_KEY);
        if (storedMySets) {
            try {
                mySets = JSON.parse(storedMySets);
            } catch (e) {
                console.error("Error parsing My Sets from localStorage:", e);
                mySets = [];
            }
        }
    }

    function saveMySetsToStorage() {
        localStorage.setItem(MY_SETS_STORAGE_KEY, JSON.stringify(mySets));
    }

    function renderMySetList() {
        const mysetsContainerEl = document.getElementById('mysets-container');
        const noMySetsMsgEl = document.getElementById('no-mysets-message'); 
        if (!mysetsContainerEl || !noMySetsMsgEl) return; 

        const dynamicItems = mysetsContainerEl.querySelectorAll('.myset-item');
        dynamicItems.forEach(item => item.remove());

        if (mySets.length === 0) {
            noMySetsMsgEl.style.display = 'block';
            noMySetsMsgEl.textContent = t.noMySets;
            return;
        }
        noMySetsMsgEl.style.display = 'none';

        const fragment = document.createDocumentFragment();
        mySets.forEach((set, index) => {
            const setDiv = document.createElement('div');
            setDiv.className = 'myset-item p-3 border rounded-md flex justify-between items-center';
           
            const setNamePara = document.createElement('p');
            setNamePara.className = 'text-sm break-all flex-grow mr-2'; 
            setNamePara.style.color = 'var(--text-primary)';
            setNamePara.textContent = set.name || t.unnamedMySet || "(Unnamed Set)"; 
            setNamePara.title = `${set.original.substring(0,50)}...\n---\n${set.translation.substring(0,50)}...`;

            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'myset-item-buttons flex-shrink-0';

            const loadBtn = document.createElement('button');
            loadBtn.className = 'btn btn-info btn-small';
            loadBtn.textContent = currentSelectedLang === 'ja' ? "読込" : "Load"; 
            loadBtn.addEventListener('click', () => {
                originalTextInput.value = set.original;
                translationTextInput.value = set.translation;
                lastOriginalTextForIncorrectTracking = set.original;
                lastTranslationTextForIncorrectTracking = set.translation;
                incorrectlyAnsweredPairs.clear();
                isFilteringIncorrect = false;
                showMessage(t.mySetLoaded(set.name || t.unnamedMySet), "success", false); 
                if (!mysetsContainerEl.classList.contains('hidden')) { 
                    mysetsContainerEl.classList.add('hidden');
                    updateToggleMySetsButtonText();
                }
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn btn-danger btn-small';
            deleteBtn.textContent = currentSelectedLang === 'ja' ? "削除" : "Delete"; 
            deleteBtn.addEventListener('click', () => {
                if (confirm(t.confirmDeleteMySet(set.name || t.unnamedMySet))) { 
                    mySets.splice(index, 1);
                    saveMySetsToStorage();
                    renderMySetList();
                    showMessage(t.mySetDeleted(set.name || t.unnamedMySet), "success", false); 
                }
            });
           
            buttonsDiv.appendChild(loadBtn);
            buttonsDiv.appendChild(deleteBtn);
            setDiv.appendChild(setNamePara);
            setDiv.appendChild(buttonsDiv);
            fragment.appendChild(setDiv);
        });
        mysetsContainerEl.appendChild(fragment);
    }
   
    saveMySetBtn.addEventListener('click', () => {
        const original = originalTextInput.value.trim();
        const translation = translationTextInput.value.trim();

        if (!original && !translation) { 
            showMessage(t.errorSavingMySetEmpty, "error", false); 
            return;
        }

        let setName = prompt(t.enterMySetName, original.substring(0, 20) + "..."); 
        if (setName === null) return; // User cancelled prompt
        setName = setName.trim();
        if (!setName) {
             showMessage(t.errorSavingMySetNoName, "error", false); 
            return;
        }

        mySets.unshift({ name: setName, original, translation }); 
        if(mySets.length > MAX_TEXT_HISTORY_ITEMS) { // Reuse history item limit for sets too
            mySets.pop();
        }
        saveMySetsToStorage();
        renderMySetList();
        showMessage(t.mySetSaved(setName), "success", false); 
    });

    toggleMySetsBtn.addEventListener('click', () => {
        const mysetsContainerEl = document.getElementById('mysets-container'); 
        if (mysetsContainerEl) {
            mysetsContainerEl.classList.toggle('hidden');
            updateToggleMySetsButtonText();
        }
    });


    // --- Filter Incorrect Pairs Feature ---
    function updateFilterIncorrectButtonState() {
        if (!filterIncorrectBtn) return;

        if (incorrectlyAnsweredPairs.size === 0) {
            filterIncorrectBtn.disabled = true;
            filterIncorrectBtn.textContent = t.filterIncorrect; 
            if(isFilteringIncorrect) { 
                isFilteringIncorrect = false; 
                renderSentences(); 
            }
        } else {
            filterIncorrectBtn.disabled = false;
            if (isFilteringIncorrect) {
                filterIncorrectBtn.textContent = t.showAllPairs;
            } else {
                filterIncorrectBtn.textContent = `${t.filterIncorrect} (${incorrectlyAnsweredPairs.size})`;
            }
        }
    }


    // --- Learning Content Rendering Function ---
    function normalizeAnswerForComparison(answer) {
        let normalized = String(answer || '').trim();
        // Remove common sentence-ending punctuation for more lenient checking
        if (normalized.endsWith('。') || normalized.endsWith('.') || normalized.endsWith('！') || normalized.endsWith('？') || normalized.endsWith('!') || normalized.endsWith('?')) {
            normalized = normalized.slice(0, -1);
        }
        // Remove all spaces (half-width and full-width)
        normalized = normalized.replace(/\s+/g, '').replace(/　+/g, ''); 
        return normalized.trim().toLowerCase(); // Case-insensitive
    }
   
    function generatePairId(original, translation) {
        // Simple ID generation, could be improved for very long texts or special chars
        const sanitize = (str) => String(str)
            .replace(/\r\n|\r|\n/g, "__NL__") 
            .replace(/"/g, "__DQ__") 
            .replace(/'/g, "__SQ__") 
            .replace(/\[/g, "__LB__") 
            .replace(/\]/g, "__RB__") 
            .replace(/\./g, "__DT__"); 
        return `pairid-${sanitize(original)}-${sanitize(translation)}`;
    }

    function renderSidebar(pairsToDisplay) {
        sidebarSentenceList.innerHTML = ''; 
        if (!learningSection.classList.contains('hidden') && pairsToDisplay.length > 0) {
            pairsToDisplay.forEach(pair => {
                const item = document.createElement('div');
                item.className = 'sidebar-item';
                item.textContent = pair.original.substring(0, 30) + (pair.original.length > 30 ? '...' : ''); 
                item.dataset.pairId = pair.id; 
                if (pair.id === activeSidebarItemId) {
                    item.classList.add('active');
                }
                item.addEventListener('click', () => {
                    const targetPairId = item.dataset.pairId; 
                    const selector = `.sentence-pair[data-id="${CSS.escape(targetPairId)}"]`; 
                    const targetSentencePair = document.querySelector(selector);

                    if (targetSentencePair) {
                        targetSentencePair.scrollIntoView({ behavior: 'smooth', block: 'start' }); 
                        setActiveSidebarItem(targetPairId);
                        if (window.innerWidth <= 768 && appSidebar.classList.contains('open')) { 
                            appSidebar.classList.remove('open');
                            contentWrapper.classList.remove('sidebar-open'); 
                        }
                    } else {
                        console.warn("Sidebar click: Target sentence pair not found for ID:", targetPairId, "with selector:", selector);
                    }
                });
                sidebarSentenceList.appendChild(item);
            });
        }
    }
   
    function setActiveSidebarItem(pairId) {
        activeSidebarItemId = pairId;
        document.querySelectorAll('#sidebar-sentence-list .sidebar-item').forEach(item => {
            item.classList.toggle('active', item.dataset.pairId === pairId);
        });
    }


    function renderSentences() {
        sentenceContainer.innerHTML = ''; 
        if (toggleAllTranslationsBtn) { 
            toggleAllTranslationsBtn.classList.toggle('hidden', currentMode !== 'memorization' || currentPairedSentences.length === 0);
        }

        let pairsToRender = currentPairedSentences;
        if (isFilteringIncorrect && incorrectlyAnsweredPairs.size > 0) {
            pairsToRender = currentPairedSentences.filter(pair => incorrectlyAnsweredPairs.has(pair.id));
            if (pairsToRender.length === 0 && currentPairedSentences.length > 0) { 
                showMessage(t.noIncorrectPairsToFilter, "info", true, 4000);
            }
        }
        renderSidebar(pairsToRender); 

        if (pairsToRender.length === 0) { 
            if (isFilteringIncorrect && currentPairedSentences.length > 0) {
                // Message handled above
            } else if (!isFilteringIncorrect && currentPairedSentences.length === 0) {
                 showMessage("noPairsToDisplay", "warning", true); 
            }
             updateUndoRedoButtonStates();
             updateFilterIncorrectButtonState(); 
             return; 
        }
       
        if (currentMode === 'memorization' && toggleAllTranslationsBtn) {
            toggleAllTranslationsBtn.textContent = allTranslationsManuallyToggled ? t.hideAllTranslations : t.showAllTranslations;
        }

        pairsToRender.forEach((sentenceData) => { 
            const pairDiv = document.createElement('div');
            pairDiv.className = 'sentence-pair'; 
            pairDiv.dataset.id = sentenceData.id; 

            const originalPara = document.createElement('p');
            originalPara.className = 'original-sentence'; 
            originalPara.textContent = sentenceData.original;

            const translationPara = document.createElement('p');
            translationPara.className = 'translation-sentence'; 
            translationPara.textContent = sentenceData.translation;

            if (currentMode === 'memorization') {
                const toggleBtn = document.createElement('button');
                toggleBtn.dataset.pairId = sentenceData.id; 
                let toggleBtnClasses = 'btn mt-2 mb-3 individual-toggle-btn '; 

                if (displayPriority === 'originalFirst') {
                    toggleBtnClasses += 'btn-toggle-original-first'; 
                    translationPara.classList.toggle('hidden', !allTranslationsManuallyToggled); 
                    toggleBtn.textContent = translationPara.classList.contains('hidden') ? t.showTranslation : t.hideTranslation;
                } else { 
                    toggleBtnClasses += 'btn-toggle-translation-first'; 
                    originalPara.classList.toggle('hidden', !allTranslationsManuallyToggled); 
                    toggleBtn.textContent = originalPara.classList.contains('hidden') ? t.showOriginal : t.hideOriginal;
                }
                toggleBtn.className = toggleBtnClasses;
                toggleBtn.addEventListener('click', () => {
                    if (displayPriority === 'originalFirst') {
                        translationPara.classList.toggle('hidden');
                        toggleBtn.textContent = translationPara.classList.contains('hidden') ? t.showTranslation : t.hideTranslation;
                    } else {
                        originalPara.classList.toggle('hidden');
                        toggleBtn.textContent = originalPara.classList.contains('hidden') ? t.showOriginal : t.hideOriginal;
                    }
                   
                    // Check if all are now effectively shown or hidden to update the master toggle button
                    let allCurrentlyEffectivelyShown = true;
                    document.querySelectorAll('#sentence-container .sentence-pair').forEach(renderedPairDiv => {
                        const targetElement = displayPriority === 'originalFirst' 
                            ? renderedPairDiv.querySelector('.translation-sentence') 
                            : renderedPairDiv.querySelector('.original-sentence');
                        if (targetElement && targetElement.classList.contains('hidden')) {
                             allCurrentlyEffectivelyShown = false;
                        }
                    });
                    allTranslationsManuallyToggled = allCurrentlyEffectivelyShown;
                    if (toggleAllTranslationsBtn) {
                        toggleAllTranslationsBtn.textContent = allTranslationsManuallyToggled ? t.hideAllTranslations : t.showAllTranslations;
                    }
                });

                if (displayPriority === 'originalFirst') {
                    pairDiv.appendChild(originalPara);
                    pairDiv.appendChild(toggleBtn);
                    pairDiv.appendChild(translationPara);
                } else {
                    pairDiv.appendChild(translationPara);
                    pairDiv.appendChild(toggleBtn);
                    pairDiv.appendChild(originalPara);
                }
            } else if (currentMode === 'test' || currentMode === 'audio') {
                let questionParaDOM, answerParaDOM, questionTextKey, answerTextKey, placeholderKey, correctAnswerKeyValue;

                if (displayPriority === 'originalFirst') {
                    questionParaDOM = originalPara;
                    answerParaDOM = translationPara;
                    questionTextKey = 'original';
                    answerTextKey = 'translation';
                    placeholderKey = 'enterYourAnswerPlaceholder'; 
                    correctAnswerKeyValue = sentenceData.translation;
                } else { // translationFirst
                    questionParaDOM = translationPara;
                    answerParaDOM = originalPara;
                    questionTextKey = 'translation';
                    answerTextKey = 'original';
                    placeholderKey = 'enterYourOriginalPlaceholder'; 
                    correctAnswerKeyValue = sentenceData.original;
                }

                answerParaDOM.classList.add('hidden'); 

                const testArea = document.createElement('div');
                testArea.className = 'test-area mt-3 space-y-2';
                const userAnswerInput = document.createElement('textarea');
                userAnswerInput.className = 'user-answer-input w-full p-2 border rounded-md resize-y';
                userAnswerInput.rows = 2;
                userAnswerInput.placeholder = t[placeholderKey] || (placeholderKey === 'enterYourOriginalPlaceholder' ? (currentSelectedLang === 'ja' ? "ここに原文を入力してください" : "Enter original text here") : t.enterYourAnswerPlaceholder);

                const checkAnswerBtn = document.createElement('button');
                // Make checkAnswerBtn larger by removing btn-small and relying on .btn default or .btn-primary if it has larger padding
                checkAnswerBtn.className = 'check-answer-btn btn btn-primary'; // Removed btn-small
                checkAnswerBtn.textContent = t.checkAnswer;

                const manualCorrectBtn = document.createElement('button');
                manualCorrectBtn.className = 'manual-correct-btn btn btn-success btn-small ml-2';
                manualCorrectBtn.textContent = t.markCorrectManual;
                manualCorrectBtn.disabled = true; // Initially disabled until after first check

                const manualIncorrectBtn = document.createElement('button');
                manualIncorrectBtn.className = 'manual-incorrect-btn btn btn-danger btn-small ml-2';
                manualIncorrectBtn.textContent = t.markIncorrectManual;
                manualIncorrectBtn.disabled = true; // Initially disabled until after first check


                const answerResultDiv = document.createElement('div');
                answerResultDiv.className = 'answer-result text-lg font-bold mt-1';

                const handleManualMarking = (isCorrect) => {
                    answerResultDiv.textContent = isCorrect 
                        ? `${t.correctAnswerSymbol} ${t.answerCorrect}` 
                        : `${t.incorrectAnswerSymbol} ${t.answerIncorrect}`;
                    answerResultDiv.className = `answer-result text-lg font-bold mt-1 ${isCorrect ? 'answer-correct' : 'answer-incorrect'}`;
                    
                    if (isCorrect) {
                        incorrectlyAnsweredPairs.delete(sentenceData.id);
                    } else {
                        incorrectlyAnsweredPairs.add(sentenceData.id);
                    }
                    answerParaDOM.classList.remove('hidden');
                    if (currentMode === 'audio') {
                        questionParaDOM.classList.remove('hidden');
                        const qToggleBtn = pairDiv.querySelector('.audio-toggle-question');
                        const aToggleBtn = pairDiv.querySelector('.audio-toggle-answer');
                        if (qToggleBtn) qToggleBtn.textContent = questionTextKey === 'original' ? t.hideOriginalAudio : t.hideTranslationAudio;
                        if (aToggleBtn) aToggleBtn.textContent = answerTextKey === 'original' ? t.hideOriginalAudio : t.hideTranslationAudio;
                    }
                    // checkAnswerBtn remains disabled
                    // manualCorrectBtn and manualIncorrectBtn remain enabled for further changes
                    updateFilterIncorrectButtonState();
                };

                manualCorrectBtn.addEventListener('click', () => handleManualMarking(true));
                manualIncorrectBtn.addEventListener('click', () => handleManualMarking(false));


                if (currentMode === 'audio') {
                    questionParaDOM.classList.add('hidden'); 

                    const audioControlsDiv = document.createElement('div');
                    audioControlsDiv.className = 'audio-controls my-3 space-y-2';
                    if (sentenceData.audioSrc) {
                        const audioPlayer = document.createElement('audio');
                        audioPlayer.className = 'audio-player';
                        audioPlayer.controls = true;
                        audioPlayer.src = sentenceData.audioSrc;
                        audioControlsDiv.appendChild(audioPlayer);
                    } else {
                        const noAudioMsg = document.createElement('p');
                        noAudioMsg.className = 'text-sm';
                        noAudioMsg.style.color = 'var(--text-secondary)';
                        noAudioMsg.textContent = t.noAudioForThisPair;
                        audioControlsDiv.appendChild(noAudioMsg);
                    }

                    const buttonContainer = document.createElement('div');
                    buttonContainer.className = 'flex flex-wrap gap-2 mt-2';

                    const toggleQuestionBtn = document.createElement('button');
                    toggleQuestionBtn.className = 'btn btn-secondary btn-small audio-toggle-question';
                    let questionBtnShowText = questionTextKey === 'original' ? t.showOriginalAudio : t.showTranslationAudio;
                    let questionBtnHideText = questionTextKey === 'original' ? t.hideOriginalAudio : t.hideTranslationAudio;
                    toggleQuestionBtn.textContent = questionParaDOM.classList.contains('hidden') ? questionBtnShowText : questionBtnHideText;
                    toggleQuestionBtn.addEventListener('click', () => {
                        questionParaDOM.classList.toggle('hidden');
                        toggleQuestionBtn.textContent = questionParaDOM.classList.contains('hidden') ? questionBtnShowText : questionBtnHideText;
                    });

                    const toggleAnswerBtn = document.createElement('button'); 
                    toggleAnswerBtn.className = 'btn btn-secondary btn-small audio-toggle-answer';
                    let answerBtnShowText = answerTextKey === 'original' ? t.showOriginalAudio : t.showTranslationAudio;
                    let answerBtnHideText = answerTextKey === 'original' ? t.hideOriginalAudio : t.hideTranslationAudio;
                    toggleAnswerBtn.textContent = answerParaDOM.classList.contains('hidden') ? answerBtnShowText : answerBtnHideText;
                    toggleAnswerBtn.addEventListener('click', () => {
                        answerParaDOM.classList.toggle('hidden');
                        toggleAnswerBtn.textContent = answerParaDOM.classList.contains('hidden') ? answerBtnShowText : answerBtnHideText;
                    });

                    buttonContainer.appendChild(toggleQuestionBtn);
                    buttonContainer.appendChild(toggleAnswerBtn);
                    audioControlsDiv.appendChild(buttonContainer);
                    pairDiv.appendChild(audioControlsDiv);
                } else { // Test mode
                    questionParaDOM.classList.remove('hidden'); 
                }

                pairDiv.appendChild(questionParaDOM);
                pairDiv.appendChild(testArea);
                pairDiv.appendChild(answerParaDOM);

                const buttonGroupDiv = document.createElement('div'); // For check and manual buttons
                buttonGroupDiv.className = 'flex flex-wrap gap-2 mt-1 items-center'; // Added items-center
                buttonGroupDiv.appendChild(checkAnswerBtn);
                buttonGroupDiv.appendChild(manualCorrectBtn);
                buttonGroupDiv.appendChild(manualIncorrectBtn);
                
                testArea.appendChild(userAnswerInput);
                testArea.appendChild(buttonGroupDiv); // Add the group
                testArea.appendChild(answerResultDiv);

                checkAnswerBtn.addEventListener('click', () => {
                    const userAnswer = userAnswerInput.value;
                    const normalizedUserAnswer = normalizeAnswerForComparison(userAnswer);
                    const normalizedCorrectAnswer = normalizeAnswerForComparison(correctAnswerKeyValue);

                    if (normalizedUserAnswer === normalizedCorrectAnswer) {
                        answerResultDiv.textContent = `${t.correctAnswerSymbol} ${t.answerCorrect}`;
                        answerResultDiv.className = 'answer-result text-lg font-bold mt-1 answer-correct';
                        incorrectlyAnsweredPairs.delete(sentenceData.id);
                    } else {
                        answerResultDiv.textContent = `${t.incorrectAnswerSymbol} ${t.answerIncorrect}`;
                        answerResultDiv.className = 'answer-result text-lg font-bold mt-1 answer-incorrect';
                        incorrectlyAnsweredPairs.add(sentenceData.id);
                    }
                    answerParaDOM.classList.remove('hidden'); 

                    if (currentMode === 'audio') {
                        questionParaDOM.classList.remove('hidden'); 
                        // Update toggle button texts
                        const qToggleBtn = pairDiv.querySelector('.audio-toggle-question');
                        const aToggleBtn = pairDiv.querySelector('.audio-toggle-answer');
                        if (qToggleBtn) qToggleBtn.textContent = questionTextKey === 'original' ? t.hideOriginalAudio : t.hideTranslationAudio;
                        if (aToggleBtn) aToggleBtn.textContent = answerTextKey === 'original' ? t.hideOriginalAudio : t.hideTranslationAudio;
                    }
                    checkAnswerBtn.disabled = true;
                    manualCorrectBtn.disabled = false; // Enable manual buttons after check
                    manualIncorrectBtn.disabled = false; // Enable manual buttons after check
                    updateFilterIncorrectButtonState();
                });
            }

            // Merge buttons (common for all modes if index > 0)
            const originalFullListIndex = currentPairedSentences.findIndex(p => p.id === sentenceData.id);
            if (originalFullListIndex > 0) { 
                const mergeButtonContainer = document.createElement('div');
                mergeButtonContainer.className = 'mt-3 border-t pt-3 flex flex-wrap gap-2 justify-start';
                mergeButtonContainer.style.borderColor = 'var(--input-border)'; 

                const mergeOriginalBtn = document.createElement('button');
                mergeOriginalBtn.className = 'btn btn-warning btn-small';
                mergeOriginalBtn.textContent = t.mergeWithPreviousOriginal;
                mergeOriginalBtn.dataset.index = originalFullListIndex; 
                mergeOriginalBtn.dataset.type = 'original';
                mergeOriginalBtn.addEventListener('click', handleMergeWithPrevious);

                const mergeTranslationBtn = document.createElement('button');
                mergeTranslationBtn.className = 'btn btn-warning btn-small';
                mergeTranslationBtn.textContent = t.mergeWithPreviousTranslation;
                mergeTranslationBtn.dataset.index = originalFullListIndex; 
                mergeTranslationBtn.dataset.type = 'translation';
                mergeTranslationBtn.addEventListener('click', handleMergeWithPrevious);

                const mergePairBtn = document.createElement('button');
                mergePairBtn.className = 'btn btn-info btn-small';
                mergePairBtn.textContent = t.mergePairWithPrevious;
                mergePairBtn.dataset.index = originalFullListIndex; 
                mergePairBtn.dataset.type = 'full_pair';
                mergePairBtn.addEventListener('click', handleMergeWithPrevious);

                mergeButtonContainer.appendChild(mergeOriginalBtn);
                mergeButtonContainer.appendChild(mergeTranslationBtn);
                mergeButtonContainer.appendChild(mergePairBtn);
                pairDiv.appendChild(mergeButtonContainer);
            }
            sentenceContainer.appendChild(pairDiv);
        });
        updateUndoRedoButtonStates();
        updateFilterIncorrectButtonState(); 
    }
   

    // --- Event Listeners ---
    modeButtons.forEach(button => {
        button.addEventListener('click', () => {
            currentMode = button.dataset.mode;
            allTranslationsManuallyToggled = false; 
            updateModeSelectionUI(); 
        });
    });

    filterIncorrectBtn.addEventListener('click', () => {
        if (incorrectlyAnsweredPairs.size > 0 || isFilteringIncorrect) { 
            isFilteringIncorrect = !isFilteringIncorrect;
        } else {
            isFilteringIncorrect = false; 
        }
        renderSentences(); 
        updateFilterIncorrectButtonState(); 
    });


    toggleDisplayPriorityBtn.addEventListener('click', () => {
        displayPriority = displayPriority === 'originalFirst' ? 'translationFirst' : 'originalFirst';
        allTranslationsManuallyToggled = false; 
        updateUIText(); // This will update button text and style
        if (!learningSection.classList.contains('hidden') && currentPairedSentences.length > 0) {
            renderSentences(); // Re-render to apply new priority
        }
    });

    startLearningBtn.addEventListener('click', () => {
        messageArea.innerHTML = ''; 
        const currentOriginalText = originalTextInput.value;
        const currentTranslationText = translationTextInput.value;

        if (!currentOriginalText.trim() && !currentTranslationText.trim()) {
            showMessage(t.errorBothTextsRequired, "error"); 
            return;
        }
        if (!currentOriginalText.trim() || !currentTranslationText.trim()) {
             showMessage(t.errorBothTextsRequired, "error"); 
            return;
        }
       
        // Reset incorrect tracking if text input has changed
        if (currentOriginalText !== lastOriginalTextForIncorrectTracking ||
            currentTranslationText !== lastTranslationTextForIncorrectTracking) {
            incorrectlyAnsweredPairs.clear();
            isFilteringIncorrect = false;
        }
        lastOriginalTextForIncorrectTracking = currentOriginalText;
        lastTranslationTextForIncorrectTracking = currentTranslationText;

        addEntryToTextInputHistory(currentOriginalText, currentTranslationText, null); 

        const originalSentences = splitTextIntoSentences(currentOriginalText);
        const translationSentences = splitTextIntoSentences(currentTranslationText);

        if (originalSentences.length === 0 || translationSentences.length === 0) {
            showMessage("errorNoValidSentences", "error", true); 
            return;
        }
       
        currentPairedSentences = []; 
        clearUndoRedoHistory(); 
        allTranslationsManuallyToggled = false; 

        const pairCount = Math.min(originalSentences.length, translationSentences.length);

        if (originalSentences.length !== translationSentences.length) {
            showMessage(t.warningSentenceCountMismatch(originalSentences.length, translationSentences.length, pairCount), "warning", false); // isKey=false for functions
        } else {
            showMessage(t.successPairsCreated(pairCount), "success", false); // isKey=false for functions
        }

        let audioAssignedCount = 0;
        for (let i = 0; i < pairCount; i++) {
            const audioSrc =
                loadedAudioFiles[i] // Assign audio if available, regardless of currentMode at this stage
                    ? loadedAudioFiles[i].url
                    : null;
            if (audioSrc) audioAssignedCount++;
            currentPairedSentences.push({
                id: generatePairId(originalSentences[i], translationSentences[i]), 
                original: originalSentences[i],
                translation: translationSentences[i],
                audioSrc: audioSrc // Audio src is now always assigned if files are loaded
            });
        }

        if (currentMode === 'audio') { // Check specifically for audio mode warnings
            if (loadedAudioFiles.length === 0 && pairCount > 0) { 
                showMessage("errorNoAudioFilesSelectedForAudioMode", "warning", true, 5000);
            } else if (audioAssignedCount < pairCount && pairCount > 0 && loadedAudioFiles.length > 0) {
                showMessage(t.warningNotAllPairsHaveAudio(audioAssignedCount, pairCount), "warning", false, 5000);
            }
        }
       
        inputSection.classList.add('hidden');
        learningSection.classList.remove('hidden'); 
        updateModeSelectionUI(); // This will call renderSentences
       
        window.scrollTo({ top: 0, behavior: 'smooth' }); 
    });

    function handleMergeWithPrevious(event) {
        const currentIndex = parseInt(event.target.dataset.index, 10); 
        const type = event.target.dataset.type;

        if (currentIndex > 0 && currentIndex < currentPairedSentences.length) {
            saveStateForUndo(); 

            const previousPair = currentPairedSentences[currentIndex - 1];
            const currentMergingPair = currentPairedSentences[currentIndex];
            let messageKey = "";

            // Remove merged items from incorrect set
            incorrectlyAnsweredPairs.delete(currentMergingPair.id);
            incorrectlyAnsweredPairs.delete(previousPair.id); 


            if (type === 'original') {
                previousPair.original = (previousPair.original + " " + currentMergingPair.original).trim();
                // Shift original texts up
                for (let i = currentIndex; i < currentPairedSentences.length - 1; i++) {
                    currentPairedSentences[i].original = currentPairedSentences[i + 1].original;
                }
                if (currentPairedSentences.length > currentIndex) { 
                     currentPairedSentences[currentPairedSentences.length -1].original = ""; // Clear last original
                }
                messageKey = "successMerged";
            } else if (type === 'translation') {
                previousPair.translation = (previousPair.translation + " " + currentMergingPair.translation).trim();
                // Shift translation texts up
                for (let i = currentIndex; i < currentPairedSentences.length - 1; i++) {
                    currentPairedSentences[i].translation = currentPairedSentences[i + 1].translation;
                }
                 if (currentPairedSentences.length > currentIndex) { 
                    currentPairedSentences[currentPairedSentences.length -1].translation = ""; // Clear last translation
                }
                messageKey = "successMerged";
            } else if (type === 'full_pair') {
                previousPair.original = (previousPair.original + " " + currentMergingPair.original).trim();
                previousPair.translation = (previousPair.translation + " " + currentMergingPair.translation).trim();
                // If previous pair didn't have audio but current one does, take current's audio
                if (!previousPair.audioSrc && currentMergingPair.audioSrc) {
                    previousPair.audioSrc = currentMergingPair.audioSrc;
                }
                currentPairedSentences.splice(currentIndex, 1); // Remove the merged pair
                messageKey = "successPairMerged";
            }
           
            // Regenerate ID for the modified previousPair
            if (previousPair) { 
                 previousPair.id = generatePairId(previousPair.original, previousPair.translation);
            }

            // If a partial merge (original or translation) results in an empty pair at the end, remove it
            if (type === 'original' || type === 'translation') {
                if (currentPairedSentences.length > 0) {
                    const lastPairIndex = currentPairedSentences.length - 1;
                    if (currentPairedSentences[lastPairIndex].original === "" && currentPairedSentences[lastPairIndex].translation === "") {
                        incorrectlyAnsweredPairs.delete(currentPairedSentences[lastPairIndex].id); 
                        currentPairedSentences.splice(lastPairIndex, 1);
                    }
                }
            }
           
            allTranslationsManuallyToggled = false; 
            renderSentences();
            showMessage(messageKey, "success", true);
            updateFilterIncorrectButtonState(); 
        }
    }
   
    undoMergeBtn.addEventListener('click', () => {
        if (undoHistory.length > 0) {
            const previousState = undoHistory.pop();
            currentPairedSentences = previousState.pairs;
            incorrectlyAnsweredPairs = new Set(previousState.incorrectIds); 
            isFilteringIncorrect = false; // Reset filter state on undo

            allTranslationsManuallyToggled = false; 
            renderSentences();
            showMessage("successUndo", "success", true); 
            updateUndoRedoButtonStates(); 
            updateFilterIncorrectButtonState();
        } else {
            showMessage("errorNoUndoState", "warning", true); 
        }
    });

    shufflePairsBtn.addEventListener('click', () => {
        if (currentPairedSentences.length > 1) {
            saveStateForUndo(); 
            for (let i = currentPairedSentences.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentPairedSentences[i], currentPairedSentences[j]] = [currentPairedSentences[j], currentPairedSentences[i]];
            }
            allTranslationsManuallyToggled = false; 
            renderSentences();
            showMessage(t.successShuffled, "success", true);
        }
    });

    toggleAllTranslationsBtn.addEventListener('click', () => {
        if (currentMode !== 'memorization' || currentPairedSentences.length === 0) return;

        allTranslationsManuallyToggled = !allTranslationsManuallyToggled; 

        const renderedPairDivs = sentenceContainer.querySelectorAll('.sentence-pair');

        renderedPairDivs.forEach(pairDiv => {
            const originalEl = pairDiv.querySelector('.original-sentence');
            const translationEl = pairDiv.querySelector('.translation-sentence');
            const individualToggleBtn = pairDiv.querySelector('.individual-toggle-btn');

            if (!originalEl || !translationEl || !individualToggleBtn) return; 

            if (displayPriority === 'originalFirst') {
                translationEl.classList.toggle('hidden', !allTranslationsManuallyToggled);
                individualToggleBtn.textContent = allTranslationsManuallyToggled ? t.hideTranslation : t.showTranslation;
            } else { 
                originalEl.classList.toggle('hidden', !allTranslationsManuallyToggled);
                individualToggleBtn.textContent = allTranslationsManuallyToggled ? t.hideOriginal : t.showOriginal;
            }
        });
       
        toggleAllTranslationsBtn.textContent = allTranslationsManuallyToggled ? t.hideAllTranslations : t.showAllTranslations;
    });


    resetAllBtn.addEventListener('click', () => {
        originalTextInput.value = '';
        translationTextInput.value = '';
        currentPairedSentences = [];
        clearUndoRedoHistory();
        revokePreviousAudioUrls(); 
        loadedAudioFiles = [];      
        if (audioFilesInput) audioFilesInput.value = ''; 
        if (audioFileNamesDisplay) audioFileNamesDisplay.textContent = t.noAudioFileSelectedDefaultText; // Reset custom display
        sentenceContainer.innerHTML = '';
        incorrectlyAnsweredPairs.clear(); 
        isFilteringIncorrect = false;
        lastOriginalTextForIncorrectTracking = ""; 
        lastTranslationTextForIncorrectTracking = ""; 

        if (!learningSection.classList.contains('hidden')) { 
            learningSection.classList.add('hidden');
            inputSection.classList.remove('hidden');
            updateSidebarVisibility();
        }
        messageArea.innerHTML = ''; 
        allTranslationsManuallyToggled = false;
        showMessage("successReset", "success", true); 
        updateFilterIncorrectButtonState(); 
        originalTextInput.focus();
    });

    backToInputBtn.addEventListener('click', () => {
        learningSection.classList.add('hidden');
        inputSection.classList.remove('hidden');
        updateSidebarVisibility();
        messageArea.innerHTML = ''; 
        allTranslationsManuallyToggled = false; 
        originalTextInput.focus();
    });
   
    toggleHistoryBtn.addEventListener('click', () => {
        historyItemsContainer.classList.toggle('hidden');
        updateToggleHistoryButtonText(); 
    });

    clearHistoryBtn.addEventListener('click', () => {
        if (textInputHistory.length > 0 && confirm(t.confirmClearHistory)) { 
            textInputHistory = [];
            saveTextInputHistoryToStorage();
            renderTextInputHistoryList(); 
            showMessage(t.historyCleared, "success", true); 
        }
    });

    importCsvBtn.addEventListener('click', () => {
        csvFileInput.click(); 
    });

    function parseCSVText_custom(csvText) {
        const records = [];
        let currentRecord = [];
        let currentField = "";
        let inQuotes = false;
        const normalizedText = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n'); // Normalize line endings

        for (let i = 0; i < normalizedText.length; i++) {
            const char = normalizedText[i];
            if (inQuotes) {
                if (char === '"') {
                    // Check for escaped quote
                    if (i + 1 < normalizedText.length && normalizedText[i + 1] === '"') {
                        currentField += '"'; // Add single quote
                        i++; // Skip next quote
                    } else {
                        inQuotes = false; // End of quoted field
                    }
                } else {
                    currentField += char; // Character inside quotes
                }
            } else { // Not in quotes
                if (char === '"') {
                     if (currentField.length === 0) { // Only start quotes if field is empty
                          inQuotes = true;
                     } else {
                          currentField += char; // Treat as normal char if field not empty (malformed CSV)
                     }
                } else if (char === ',') {
                    currentRecord.push(currentField);
                    currentField = "";
                } else if (char === '\n') {
                    currentRecord.push(currentField); // Add last field of the record
                    records.push([...currentRecord]); // Add copy of the record
                    currentRecord = []; // Reset for next record
                    currentField = "";
                } else {
                    currentField += char; // Regular character
                }
            }
        }
        // Add the last field and record if any
        currentRecord.push(currentField);
        if (currentRecord.some(f => f.trim().length > 0) || (records.length === 0 && currentRecord.length > 0) ) {
             if (!(records.length === 0 && currentRecord.length === 1 && currentRecord[0].trim() === "")) { // Avoid empty single cell
                records.push([...currentRecord]);
             }
        }
        return records.filter(record => record.length > 0 && record.some(field => field.trim() !== "")); // Filter out completely empty records
    }


    csvFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const csvText = e.target.result;
                try {
                    const parsedRows = parseCSVText_custom(csvText);
                    if (parsedRows.length > 0 && parsedRows.some(row => row.length >=1 && row[0].trim() !== "")) { 
                        let originalTextParts = [];
                        let translationTextParts = [];
                        parsedRows.forEach(rowCells => {
                            let cellA = String(rowCells.length > 0 ? rowCells[0] : "").trim();
                            let cellB = String(rowCells.length > 1 ? rowCells[1] : "").trim();
                            // Replace literal '\n' from CSV with actual newlines for textarea
                            cellA = cellA.replace(/\\n/g, '\n');
                            cellB = cellB.replace(/\\n/g, '\n');
                           
                            if (cellA) { // Only add if original text (cellA) exists
                                originalTextParts.push(cellA);
                                translationTextParts.push(cellB); // Add corresponding translation, even if empty
                            }
                        });
                        // Join parts with a common delimiter that splitTextIntoSentences will recognize
                        // Ensure each part ends with a delimiter before joining
                        const finalOriginalText = originalTextParts
                            .map(p => p.replace(/[.。？！]$/, "") + (/[一-龠ぁ-んァ-ヶ]/.test(p) ? "。" : ".")) // Add delimiter if missing
                            .join(" "); // Join with space, split will handle it
                        const finalTranslationText = translationTextParts
                            .map(p => {
                                if (!p) return "."; // If translation is empty, use a placeholder dot
                                return p.replace(/[.。？！]$/, "") + (/[一-龠ぁ-んァ-ヶ]/.test(p) ? "。" : ".");
                            })
                            .join(" ")
                            .replace(/\s+\.\s*/g, ". ") // Clean up space around placeholder dots
                            .trim();
                        originalTextInput.value = finalOriginalText;
                        translationTextInput.value = finalTranslationText;
                       
                        // Reset incorrect tracking
                        lastOriginalTextForIncorrectTracking = finalOriginalText; 
                        lastTranslationTextForIncorrectTracking = finalTranslationText; 
                        incorrectlyAnsweredPairs.clear(); 
                        isFilteringIncorrect = false;

                        if (finalOriginalText || finalTranslationText) { 
                            showMessage("successCsvImported", "success", true);
                            addEntryToTextInputHistory(finalOriginalText, finalTranslationText, file.name); 
                            clearUndoRedoHistory(); 
                            updateUndoRedoButtonStates();
                            updateFilterIncorrectButtonState();
                        } else {
                             showMessage(t.errorCsvFormat, "error", true); 
                        }
                    } else {
                        showMessage(t.errorCsvFormat, "error", true); 
                    }
                } catch (err) {
                    showMessage(t.errorCsvFormat, "error", true); 
                    console.error("CSV Parse Error:", err);
                }
            };
            reader.readAsText(file, 'UTF-8'); // Specify UTF-8 encoding
            csvFileInput.value = ''; // Reset file input
        }
    });

    exportCsvBtn.addEventListener('click', () => {
        if (currentPairedSentences.length === 0) {
            showMessage("errorNoPairsToExport", "warning", true); 
            return;
        }
        let csvContent = '"Original","Translation"\n'; // CSV Header
        currentPairedSentences.forEach(pair => {
            // Escape double quotes within fields by doubling them
            const original = `"${pair.original.replace(/"/g, '""')}"`;
            const translation = `"${pair.translation.replace(/"/g, '""')}"`;
            csvContent += `${original},${translation}\n`;
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        if (link.download !== undefined) { // Feature detection
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "learned_pairs.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url); // Clean up
        } else {
            showMessage(t.csvExportNotSupported, "warning", true); 
        }
    });

    clearAppDataBtn.addEventListener('click', () => {
        if (confirm(t.confirmClearAppData)) {
            localStorage.removeItem(TEXT_HISTORY_STORAGE_KEY);
            localStorage.removeItem(MY_SETS_STORAGE_KEY);
            localStorage.removeItem(THEME_STORAGE_KEY);
            localStorage.removeItem(LANGUAGE_STORAGE_KEY);
            showMessage(t.appDataCleared, "success", false, 4000); 
            setTimeout(() => window.location.reload(), 1500); 
        }
    });


    // --- Sidebar Logic ---
    function updateSidebarVisibility() {
        const isLearning = !learningSection.classList.contains('hidden');
        const sidebarOpen = appSidebar.classList.contains('open');

        if (isLearning) {
            sidebarToggleBtn.classList.remove('hidden'); 
            if (sidebarOpen) {
                 if(window.innerWidth > 768) { // Only apply margin on larger screens
                    contentWrapper.classList.add('sidebar-open');
                 } 
            } else {
                 contentWrapper.classList.remove('sidebar-open');
            }
        } else { 
            appSidebar.classList.remove('open'); 
            contentWrapper.classList.remove('sidebar-open'); 
            sidebarToggleBtn.classList.add('hidden'); 
        }
    }


    sidebarToggleBtn.addEventListener('click', () => {
        appSidebar.classList.toggle('open');
        updateSidebarVisibility(); 
    });

    // --- Swipe gestures for mobile sidebar ---
    let touchStartX = 0;
    let touchEndX = 0;
    const swipeThreshold = 50; // Minimum swipe distance

    document.body.addEventListener('touchstart', (event) => {
        if (window.innerWidth > 768) return; // Only for mobile
        // Only start swipe if near edge (when closed) or anywhere (when open)
        if ((!appSidebar.classList.contains('open') && event.touches[0].clientX < 30) || appSidebar.classList.contains('open')) {
            touchStartX = event.touches[0].clientX;
        } else {
            touchStartX = 0; // Reset if touch starts elsewhere
        }
    }, { passive: true });

    document.body.addEventListener('touchmove', (event) => {
        if (window.innerWidth > 768 || touchStartX === 0) return; // Only if swipe started correctly
        touchEndX = event.touches[0].clientX;
    }, { passive: true });

    document.body.addEventListener('touchend', () => {
        if (window.innerWidth > 768 || touchStartX === 0) return; 
        const swipeDistance = touchEndX - touchStartX;

        if (!appSidebar.classList.contains('open') && swipeDistance > swipeThreshold && touchStartX < 30) { // Swipe right to open
            appSidebar.classList.add('open'); 
        } else if (appSidebar.classList.contains('open') && swipeDistance < -swipeThreshold) { // Swipe left to close
            appSidebar.classList.remove('open'); 
        }
        updateSidebarVisibility(); 
        touchStartX = 0; // Reset for next touch
        touchEndX = 0;    
    }, { passive: true });


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        loadAndApplyTheme(); 
        loadAndApplyLanguage(); 
        loadTextInputHistoryFromStorage();
        loadMySetsFromStorage(); 
        updateUndoRedoButtonStates();
        renderTextInputHistoryList();
        renderMySetList(); 
        updateModeSelectionUI(); 
        updateFilterIncorrectButtonState(); 
        updateSidebarVisibility(); 
    });

    window.addEventListener('beforeunload', () => {
        revokePreviousAudioUrls(); // Clean up audio object URLs
    });

    // --- Service Worker Registration ---
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js') // Assuming sw.js is in the same directory
            .then(reg => console.log('Service Worker registered:', reg.scope))
            .catch(err => console.error('Service Worker registration failed:', err));
        });
    }
    </script>
</body>
</html>
